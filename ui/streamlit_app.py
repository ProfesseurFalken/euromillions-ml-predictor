#!/usr/bin/env python3
"""
EuroMillions Streamlit UI
========================

Single-page graphical interface for EuroMillions ML prediction system.
Provides data management, model training, prediction generation, and export functionality.
"""

import os
import json
import streamlit as st
import pandas as pd
from datetime import datetime
from pathlib import Path
import sys

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from streamlit_adapters import (
    init_full_history,
    update_incremental,
    train_from_scratch,
    reload_models,
    get_scores,
    suggest_tickets_ui,
    fetch_last_draws,
    export_all_draws_csv,
    get_system_status
)

# Page configuration
st.set_page_config(
    page_title="EuroMillions ‚Äî Console Graphique", 
    page_icon="üé≤", 
    layout="centered"
)

def load_env_settings():
    """Load current .env settings."""
    env_file = Path(".env")
    settings = {
        "STORAGE_DIR": "./data",
        "DB_URL": "sqlite:///./data/draws.db", 
        "USER_AGENT": "EuromillionsPro/1.0 (+contact)",
        "REQUEST_TIMEOUT": "15",
        "MAX_RETRIES": "3"
    }
    
    if env_file.exists():
        with open(env_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip().strip('"\'')
                    if key in settings:
                        settings[key] = value
    
    return settings

def save_env_settings(settings):
    """Save settings to .env file."""
    env_content = []
    env_content.append("# EuroMillions Configuration")
    env_content.append("# Generated by Streamlit UI")
    env_content.append(f"# Updated: {datetime.now().isoformat()}")
    env_content.append("")
    
    for key, value in settings.items():
        env_content.append(f'{key}="{value}"')
    
    env_content.append("")
    
    with open(".env", 'w', encoding='utf-8') as f:
        f.write('\n'.join(env_content))

def format_tickets_display(tickets):
    """Format tickets for display."""
    if not tickets:
        return "Aucun ticket g√©n√©r√©"
    
    display_lines = []
    for ticket in tickets:
        balls_str = ticket['balls_str']
        stars_str = ticket['stars_str']
        # Format avec s√©paration visuelle claire et num√©ros √† la ligne
        ticket_display = f"üé´ **Ticket {ticket['ticket_id']}**\n\n   {balls_str}\n   ‚≠ê {stars_str}"
        display_lines.append(ticket_display)
    
    return '\n\n'.join(display_lines)

def main():
    """Main Streamlit application."""
    
    # Title and header
    st.title("üé≤ EuroMillions ‚Äî Console Graphique")
    st.markdown("Interface de gestion compl√®te pour le syst√®me de pr√©diction EuroMillions")
    
    # Sidebar configuration
    with st.sidebar:
        st.header("üéØ Suggestions")
        
        # Suggestion parameters
        n_tickets = st.slider(
            "Nombre de tickets",
            min_value=1,
            max_value=20,
            value=10,
            help="Nombre de combinaisons √† g√©n√©rer"
        )
        
        method = st.selectbox(
            "M√©thode de g√©n√©ration",
            options=["hybrid", "topk", "random"],
            index=0,
            help="Strat√©gie de s√©lection des num√©ros"
        )
        
        seed = st.number_input(
            "Graine al√©atoire",
            min_value=1,
            max_value=9999,
            value=42,
            help="Pour reproductibilit√© des r√©sultats"
        )
        
        st.markdown("---")
        
        # Settings expander
        with st.expander("‚öôÔ∏è Param√®tres (.env)"):
            st.subheader("Configuration syst√®me")
            
            # Load current settings
            current_settings = load_env_settings()
            
            # Settings form
            with st.form("env_settings"):
                new_settings = {}
                
                new_settings["STORAGE_DIR"] = st.text_input(
                    "R√©pertoire de stockage",
                    value=current_settings["STORAGE_DIR"],
                    help="Dossier pour les donn√©es"
                )
                
                new_settings["DB_URL"] = st.text_input(
                    "URL de base de donn√©es",
                    value=current_settings["DB_URL"],
                    help="Chemin vers la base SQLite"
                )
                
                new_settings["USER_AGENT"] = st.text_input(
                    "User Agent",
                    value=current_settings["USER_AGENT"],
                    help="Identification pour les requ√™tes web"
                )
                
                new_settings["REQUEST_TIMEOUT"] = st.text_input(
                    "Timeout requ√™tes (sec)",
                    value=current_settings["REQUEST_TIMEOUT"],
                    help="D√©lai d'attente des requ√™tes"
                )
                
                new_settings["MAX_RETRIES"] = st.text_input(
                    "Nombre de tentatives",
                    value=current_settings["MAX_RETRIES"],
                    help="Retries en cas d'√©chec"
                )
                
                if st.form_submit_button("üíæ Enregistrer param√®tres"):
                    try:
                        save_env_settings(new_settings)
                        st.success("‚úÖ Param√®tres sauvegard√©s dans .env")
                        st.rerun()
                    except Exception as e:
                        st.error(f"‚ùå Erreur lors de la sauvegarde: {e}")
    
    # Main content sections
    
    # Section 1: Initialization & Updates
    st.header("üîß Initialisation & Mise √† jour")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üì• T√©l√©charger l'historique & Initialiser", use_container_width=True):
            with st.spinner("T√©l√©chargement de l'historique complet..."):
                try:
                    result = init_full_history()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        st.json(result)
                    else:
                        st.error(f"‚ùå {result['message']}")
                        st.json(result)
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de l'initialisation: {e}")
    
    with col2:
        if st.button("üîÑ Mettre √† jour (derniers tirages)", use_container_width=True):
            with st.spinner("Mise √† jour des derniers tirages..."):
                try:
                    result = update_incremental()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        st.json(result)
                    else:
                        st.error(f"‚ùå {result['message']}")
                        st.json(result)
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de la mise √† jour: {e}")
    
    st.markdown("---")
    
    # Section 2: Training
    st.header("üß† Entra√Ænement")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üèãÔ∏è Entra√Æner (from scratch)", use_container_width=True):
            with st.spinner("Entra√Ænement des mod√®les en cours..."):
                try:
                    result = train_from_scratch()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        
                        # Display training metrics
                        metrics_col1, metrics_col2 = st.columns(2)
                        with metrics_col1:
                            if result.get("main_logloss"):
                                st.metric("Log-loss boules principales", f"{result['main_logloss']:.4f}")
                        with metrics_col2:
                            if result.get("star_logloss"):
                                st.metric("Log-loss √©toiles", f"{result['star_logloss']:.4f}")
                        
                        if result.get("training_data_size"):
                            st.info(f"üìä Donn√©es d'entra√Ænement: {result['training_data_size']} tirages")
                    else:
                        st.error(f"‚ùå {result['message']}")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de l'entra√Ænement: {e}")
    
    with col2:
        if st.button("üì¶ Recharger le mod√®le", use_container_width=True):
            with st.spinner("Rechargement du mod√®le..."):
                try:
                    result = reload_models()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        
                        if result.get("trained_at"):
                            st.info(f"üìÖ Entra√Æn√© le: {result['trained_at']}")
                    else:
                        st.error(f"‚ùå {result['message']}")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors du rechargement: {e}")
    
    st.markdown("---")
    
    # Section 3: Current Probabilities
    st.header("üìä Probabilit√©s actuelles")
    
    if st.button("üîÑ Actualiser les probabilit√©s"):
        with st.spinner("Calcul des probabilit√©s..."):
            try:
                balls_df, stars_df = get_scores()
                
                if not balls_df.empty and not stars_df.empty:
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.subheader("üé± Top 15 boules principales")
                        top_balls = balls_df.head(15)
                        st.dataframe(
                            top_balls[['ball', 'percentage', 'rank']].rename(columns={
                                'ball': 'Boule',
                                'percentage': 'Probabilit√© (%)',
                                'rank': 'Rang'
                            }),
                            use_container_width=True,
                            hide_index=True
                        )
                    
                    with col2:
                        st.subheader("‚≠ê Top 5 √©toiles")
                        top_stars = stars_df.head(5)
                        st.dataframe(
                            top_stars[['star', 'percentage', 'rank']].rename(columns={
                                'star': '√âtoile',
                                'percentage': 'Probabilit√© (%)',
                                'rank': 'Rang'
                            }),
                            use_container_width=True,
                            hide_index=True
                        )
                else:
                    st.warning("‚ö†Ô∏è Aucune probabilit√© disponible. Entra√Ænez d'abord un mod√®le.")
                    
            except Exception as e:
                st.error(f"‚ùå Erreur lors du calcul des probabilit√©s: {e}")
    
    st.markdown("---")
    
    # Section 4: Generate Tickets
    st.header("üé´ G√©n√©rer des tickets 5+2")
    
    if st.button("üé≤ G√©n√©rer les tickets", use_container_width=True):
        with st.spinner(f"G√©n√©ration de {n_tickets} tickets avec la m√©thode {method}..."):
            try:
                tickets = suggest_tickets_ui(n_tickets, method, seed)
                
                if tickets:
                    st.success(f"‚úÖ {len(tickets)} tickets g√©n√©r√©s avec succ√®s!")
                    
                    # Display tickets
                    st.subheader("üé´ Vos tickets EuroMillions")
                    
                    tickets_text = format_tickets_display(tickets)
                    st.markdown(tickets_text)
                    
                    # Prepare download data
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    
                    # CSV format
                    csv_data = []
                    csv_data.append("Ticket,Boule1,Boule2,Boule3,Boule4,Boule5,Etoile1,Etoile2")
                    for ticket in tickets:
                        balls = ticket['balls']
                        stars = ticket['stars']
                        csv_data.append(f"{ticket['ticket_id']},{balls[0]},{balls[1]},{balls[2]},{balls[3]},{balls[4]},{stars[0]},{stars[1]}")
                    csv_content = '\n'.join(csv_data)
                    
                    # JSON format
                    json_content = json.dumps({
                        "generated_at": datetime.now().isoformat(),
                        "method": method,
                        "seed": seed,
                        "tickets": tickets
                    }, indent=2, ensure_ascii=False)
                    
                    # Download buttons
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.download_button(
                            label="‚¨áÔ∏è T√©l√©charger CSV",
                            data=csv_content,
                            file_name=f"euromillions_tickets_{timestamp}.csv",
                            mime="text/csv",
                            use_container_width=True
                        )
                    
                    with col2:
                        st.download_button(
                            label="‚¨áÔ∏è T√©l√©charger JSON",
                            data=json_content,
                            file_name=f"euromillions_tickets_{timestamp}.json",
                            mime="application/json",
                            use_container_width=True
                        )
                    
                    # Method explanation
                    st.info(f"**M√©thode utilis√©e:** {method} | **Graine:** {seed}")
                    
                    method_explanations = {
                        "topk": "S√©lectionne les boules/√©toiles avec les plus hautes probabilit√©s",
                        "random": "√âchantillonnage al√©atoire pond√©r√© par les probabilit√©s",
                        "hybrid": "M√©lange de pr√©dictions top et d'√©chantillonnage al√©atoire"
                    }
                    
                    st.caption(method_explanations.get(method, "M√©thode personnalis√©e"))
                
                else:
                    st.warning("‚ö†Ô∏è Aucun ticket g√©n√©r√©. V√©rifiez que les mod√®les sont entra√Æn√©s.")
                    
            except Exception as e:
                st.error(f"‚ùå Erreur lors de la g√©n√©ration: {e}")
    
    st.markdown("---")
    
    # Section 5: Manual Draw Entry
    st.header("‚ûï Ajouter un tirage manuellement")
    
    with st.expander("üìù Saisir un nouveau tirage", expanded=False):
        st.subheader("Informations du tirage")
        
        # Date input
        draw_date = st.date_input(
            "Date du tirage",
            value=datetime.now().date(),
            help="Date du tirage officiel"
        )
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("üé± Num√©ros principaux (1-50)")
            main_numbers = []
            
            # 5 number inputs for main numbers
            for i in range(5):
                num = st.number_input(
                    f"Num√©ro {i+1}",
                    min_value=1,
                    max_value=50,
                    value=1,
                    key=f"main_{i}",
                    help=f"Num√©ro principal {i+1} (entre 1 et 50)"
                )
                main_numbers.append(num)
        
        with col2:
            st.subheader("‚≠ê √âtoiles (1-12)")
            stars = []
            
            # 2 star inputs
            for i in range(2):
                star = st.number_input(
                    f"√âtoile {i+1}",
                    min_value=1,
                    max_value=12,
                    value=1,
                    key=f"star_{i}",
                    help=f"√âtoile {i+1} (entre 1 et 12)"
                )
                stars.append(star)
        
        # Validation and preview
        col1, col2 = st.columns(2)
        
        with col1:
            # Validate inputs
            main_numbers_sorted = sorted(main_numbers)
            stars_sorted = sorted(stars)
            
            # Check for duplicates in main numbers
            main_duplicates = len(main_numbers) != len(set(main_numbers))
            # Check for duplicates in stars
            star_duplicates = len(stars) != len(set(stars))
            
            if main_duplicates:
                st.error("‚ùå Les num√©ros principaux doivent √™tre diff√©rents")
            elif star_duplicates:
                st.error("‚ùå Les √©toiles doivent √™tre diff√©rentes")
            else:
                st.success("‚úÖ Tirage valide")
                
                # Preview
                st.info(f"**Aper√ßu:** {' - '.join(map(str, main_numbers_sorted))} | ‚≠ê {' - '.join(map(str, stars_sorted))}")
        
        with col2:
            # Add button
            if st.button("üíæ Ajouter le tirage", disabled=main_duplicates or star_duplicates):
                with st.spinner("Ajout du tirage en cours..."):
                    try:
                        # Import here to avoid circular imports
                        from repository import EuromillionsRepository
                        
                        # Create draw ID
                        draw_id = f"EM-{draw_date.strftime('%Y-%m-%d')}"
                        
                        # Prepare draw data
                        draw_data = {
                            'draw_id': draw_id,
                            'draw_date': draw_date.strftime('%Y-%m-%d'),
                            'n1': main_numbers_sorted[0],
                            'n2': main_numbers_sorted[1],
                            'n3': main_numbers_sorted[2],
                            'n4': main_numbers_sorted[3],
                            'n5': main_numbers_sorted[4],
                            's1': stars_sorted[0],
                            's2': stars_sorted[1],
                            'jackpot': None,
                            'prize_table': None,
                            'raw_html': None
                        }
                        
                        # Save to database
                        repo = EuromillionsRepository()
                        result = repo.upsert_draws([draw_data])
                        
                        if result['inserted'] > 0:
                            st.success(f"‚úÖ Tirage ajout√© avec succ√®s ! (ID: {draw_id})")
                            st.info("üí° Pensez √† re-entra√Æner les mod√®les pour inclure ce nouveau tirage")
                        elif result['updated'] > 0:
                            st.warning(f"‚ö†Ô∏è Tirage existant mis √† jour (ID: {draw_id})")
                        else:
                            st.error("‚ùå √âchec de l'ajout du tirage")
                            
                    except Exception as e:
                        st.error(f"‚ùå Erreur lors de l'ajout: {e}")
    
    st.markdown("---")
    
    # Section 6: CSV Import
    st.header("üìÑ Import CSV")
    
    with st.expander("üìÇ Importer des tirages depuis un fichier CSV", expanded=False):
        st.subheader("T√©l√©chargement de fichier CSV")
        
        uploaded_file = st.file_uploader(
            "Choisissez un fichier CSV FDJ",
            type=['csv'],
            help="Fichier CSV au format FDJ avec les tirages EuroMillions"
        )
        
        if uploaded_file is not None:
            # Preview file content
            try:
                # Read a few lines for preview
                import io
                
                # Reset file pointer
                uploaded_file.seek(0)
                content = uploaded_file.read()
                
                # Try different encodings
                encodings = ['utf-8', 'latin1', 'cp1252']
                df_preview = None
                used_encoding = None
                
                for encoding in encodings:
                    try:
                        uploaded_file.seek(0)
                        df_preview = pd.read_csv(io.StringIO(content.decode(encoding)), nrows=5)
                        used_encoding = encoding
                        break
                    except:
                        continue
                
                if df_preview is not None:
                    st.subheader("Aper√ßu du fichier")
                    st.dataframe(df_preview, use_container_width=True)
                    
                    # Calculer le nombre de lignes sans backslash dans f-string
                    line_count = len(content.decode(used_encoding).split('\n'))
                    st.caption(f"Encodage d√©tect√©: {used_encoding} | Lignes totales: {line_count}")
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        if st.button("üîç Analyser le fichier complet"):
                            with st.spinner("Analyse du fichier..."):
                                try:
                                    uploaded_file.seek(0)
                                    df_full = pd.read_csv(io.StringIO(content.decode(used_encoding)))
                                    
                                    st.subheader("Statistiques du fichier")
                                    st.metric("Nombre de lignes", len(df_full))
                                    st.metric("Nombre de colonnes", len(df_full.columns))
                                    
                                    # Show column names
                                    st.subheader("Colonnes d√©tect√©es")
                                    st.write(list(df_full.columns))
                                    
                                except Exception as e:
                                    st.error(f"Erreur lors de l'analyse: {e}")
                    
                    with col2:
                        if st.button("üì• Importer les donn√©es"):
                            with st.spinner("Import des donn√©es en cours..."):
                                try:
                                    # Save temporarily and import
                                    import tempfile
                                    import os
                                    
                                    # Create temporary file
                                    with tempfile.NamedTemporaryFile(mode='wb', suffix='.csv', delete=False) as tmp_file:
                                        uploaded_file.seek(0)
                                        tmp_file.write(uploaded_file.read())
                                        temp_path = tmp_file.name
                                    
                                    # Import using existing function
                                    import subprocess
                                    import sys
                                    
                                    # Run import script
                                    result = subprocess.run([
                                        sys.executable, 'import_fdj_special.py', temp_path
                                    ], capture_output=True, text=True, cwd=os.getcwd())
                                    
                                    # Clean up
                                    os.unlink(temp_path)
                                    
                                    if result.returncode == 0:
                                        st.success("‚úÖ Import r√©ussi !")
                                        st.text("Sortie:")
                                        st.code(result.stdout)
                                        st.info("üí° Pensez √† re-entra√Æner les mod√®les avec les nouvelles donn√©es")
                                    else:
                                        st.error("‚ùå √âchec de l'import")
                                        st.text("Erreur:")
                                        st.code(result.stderr)
                                        
                                except Exception as e:
                                    st.error(f"‚ùå Erreur lors de l'import: {e}")
                else:
                    st.error("‚ùå Impossible de lire le fichier. V√©rifiez le format CSV.")
                    
            except Exception as e:
                st.error(f"‚ùå Erreur lors de la lecture du fichier: {e}")
    
    st.markdown("---")
    
    # Section 7: History
    st.header("üóÇÔ∏è Historique")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üìú Voir les 20 derniers tirages", use_container_width=True):
            with st.spinner("Chargement de l'historique..."):
                try:
                    recent_draws = fetch_last_draws(20)
                    
                    if not recent_draws.empty:
                        st.subheader("üìã Derniers tirages")
                        
                        # Format for display
                        display_df = recent_draws[['draw_date', 'balls', 'stars']].rename(columns={
                            'draw_date': 'Date',
                            'balls': 'Boules principales',
                            'stars': '√âtoiles'
                        })
                        
                        st.dataframe(
                            display_df,
                            use_container_width=True,
                            hide_index=True
                        )
                    else:
                        st.warning("‚ö†Ô∏è Aucun tirage trouv√© dans l'historique.")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors du chargement: {e}")
    
    with col2:
        if st.button("‚¨áÔ∏è Exporter l'historique (CSV)", use_container_width=True):
            with st.spinner("Pr√©paration de l'export..."):
                try:
                    filename, csv_bytes = export_all_draws_csv()
                    
                    if csv_bytes:
                        st.download_button(
                            label="üìÅ T√©l√©charger l'historique complet",
                            data=csv_bytes,
                            file_name=filename,
                            mime="text/csv",
                            use_container_width=True
                        )
                        
                        file_size = len(csv_bytes)
                        st.success(f"‚úÖ Export pr√™t: {filename} ({file_size:,} octets)")
                    else:
                        st.warning("‚ö†Ô∏è Aucune donn√©e √† exporter.")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de l'export: {e}")
    
    # Footer with system status
    st.markdown("---")
    
    with st.expander("‚ÑπÔ∏è √âtat du syst√®me"):
        try:
            status = get_system_status()
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("üìä Donn√©es")
                if status.get("data", {}).get("available", False):
                    data_info = status["data"]
                    st.success(f"‚úÖ {data_info['count']} tirages disponibles")
                    if data_info.get("first_date") and data_info.get("last_date"):
                        st.caption(f"Du {data_info['first_date']} au {data_info['last_date']}")
                else:
                    st.error("‚ùå Aucune donn√©e disponible")
            
            with col2:
                st.subheader("ü§ñ Mod√®les")
                if status.get("models", {}).get("available", False):
                    model_info = status["models"]
                    st.success("‚úÖ Mod√®les disponibles")
                    if model_info.get("trained_at"):
                        st.caption(f"Entra√Æn√©s le: {model_info['trained_at']}")
                else:
                    st.error("‚ùå Aucun mod√®le entra√Æn√©")
            
            # Recommendations
            recommendations = status.get("recommendations", [])
            if recommendations:
                st.subheader("üí° Recommandations")
                for rec in recommendations:
                    st.info(f"‚Ä¢ {rec}")
                    
        except Exception as e:
            st.error(f"‚ùå Erreur lors de la r√©cup√©ration du statut: {e}")


if __name__ == "__main__":
    main()
