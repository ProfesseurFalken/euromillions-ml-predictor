#!/usr/bin/env python3
"""
EuroMillions Streamlit UI
========================

Single-page graphical interface for EuroMillions ML prediction system.
Provides data management, model training, prediction generation, and export functionality.
"""

import os
import json
import streamlit as st
import pandas as pd
from datetime import datetime, timedelta
from pathlib import Path
import sys
import hashlib
from collections import Counter

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

# Constants
MAIN_NUM_MIN = 1
MAIN_NUM_MAX = 50
STAR_NUM_MIN = 1
STAR_NUM_MAX = 12
MAIN_NUMBERS_COUNT = 5
STAR_NUMBERS_COUNT = 2
SCORE_MAIN_WEIGHT = 10
SCORE_STAR_WEIGHT = 5
HYBRID_TOP_MAIN = 10
HYBRID_TOP_STARS = 5

# Method descriptions
METHOD_EXPLANATIONS = {
    "topk": "S√©lectionne les boules/√©toiles avec les plus hautes probabilit√©s",
    "random": "√âchantillonnage al√©atoire pond√©r√© par les probabilit√©s",
    "hybrid": "M√©lange de pr√©dictions top et d'√©chantillonnage al√©atoire",
    "ensemble": "Combine plusieurs algorithmes ML (LightGBM, XGBoost, CatBoost, RandomForest)",
    "advanced_hybrid": "Strat√©gie hybride avanc√©e (ML + fr√©quences + motifs + √©carts)",
    "enhanced_hybrid": "Version am√©lior√©e de la m√©thode hybride avec ensemble",
    "enhanced_topk": "Version am√©lior√©e du top-k avec ensemble",
    "enhanced_random": "Version am√©lior√©e de l'al√©atoire avec ensemble"
}

from streamlit_adapters import (
    init_full_history,
    update_incremental,
    train_from_scratch,
    train_ensemble_models,
    reload_models,
    get_scores,
    suggest_tickets_ui,
    fetch_last_draws,
    export_all_draws_csv,
    get_system_status
)

# Import backtesting functionality
import numpy as np
from typing import Dict, List, Any

@st.cache_data(ttl=3600)  # Cache for 1 hour
def _get_cached_probabilities():
    """Cache expensive ML probability calculations."""
    import train_models
    main_proba = train_models.score_balls()
    star_proba = train_models.score_stars()
    main_scores = {i: main_proba[i-1] for i in range(MAIN_NUM_MIN, MAIN_NUM_MAX + 1)}
    star_scores = {i: star_proba[i-1] for i in range(STAR_NUM_MIN, STAR_NUM_MAX + 1)}
    return main_scores, star_scores

# Page configuration
st.set_page_config(
    page_title="EuroMillions ‚Äî Console Graphique", 
    page_icon="üé≤", 
    layout="centered"
)

def load_env_settings():
    """Load current .env settings."""
    env_file = Path(".env")
    settings = {
        "STORAGE_DIR": "./data",
        "DB_URL": "sqlite:///./data/draws.db", 
        "USER_AGENT": "EuromillionsPro/1.0 (+contact)",
        "REQUEST_TIMEOUT": "15",
        "MAX_RETRIES": "3"
    }
    
    if env_file.exists():
        with open(env_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip().strip('"\'')
                    if key in settings:
                        settings[key] = value
    
    return settings

def save_env_settings(settings):
    """Save settings to .env file."""
    env_content = []
    env_content.append("# EuroMillions Configuration")
    env_content.append("# Generated by Streamlit UI")
    env_content.append(f"# Updated: {datetime.now().isoformat()}")
    env_content.append("")
    
    for key, value in settings.items():
        env_content.append(f'{key}="{value}"')
    
    env_content.append("")
    
    with open(".env", 'w', encoding='utf-8') as f:
        f.write('\n'.join(env_content))

def load_config_presets():
    """Load saved configuration presets."""
    preset_file = Path("data/config_presets.json")
    if preset_file.exists():
        with open(preset_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {}

def save_config_preset(name: str, config: dict):
    """Save a configuration preset."""
    presets = load_config_presets()
    presets[name] = {
        **config,
        "saved_at": datetime.now().isoformat()
    }
    preset_file = Path("data/config_presets.json")
    preset_file.parent.mkdir(exist_ok=True)
    with open(preset_file, 'w', encoding='utf-8') as f:
        json.dump(presets, f, indent=2)
    return True

def delete_config_preset(name: str):
    """Delete a configuration preset."""
    presets = load_config_presets()
    if name in presets:
        del presets[name]
        with open("data/config_presets.json", 'w', encoding='utf-8') as f:
            json.dump(presets, f, indent=2)
        return True
    return False

def validate_ticket(main_numbers: list, stars: list, main_scores: dict = None, star_scores: dict = None) -> dict:
    """Validate and score a user ticket."""
    from repository import get_repository
    
    result = {
        "valid": True,
        "errors": [],
        "warnings": [],
        "score": 0,
        "probability": 0,
        "historical_matches": [],
        "suggestions": []
    }
    
    # Validation
    if len(main_numbers) != MAIN_NUMBERS_COUNT:
        result["valid"] = False
        result["errors"].append(f"Doit contenir exactement {MAIN_NUMBERS_COUNT} num√©ros principaux")
    
    if len(stars) != STAR_NUMBERS_COUNT:
        result["valid"] = False
        result["errors"].append(f"Doit contenir exactement {STAR_NUMBERS_COUNT} √©toiles")
    
    if any(n < MAIN_NUM_MIN or n > MAIN_NUM_MAX for n in main_numbers):
        result["valid"] = False
        result["errors"].append(f"Num√©ros principaux doivent √™tre entre {MAIN_NUM_MIN} et {MAIN_NUM_MAX}")
    
    if any(s < STAR_NUM_MIN or s > STAR_NUM_MAX for s in stars):
        result["valid"] = False
        result["errors"].append(f"√âtoiles doivent √™tre entre {STAR_NUM_MIN} et {STAR_NUM_MAX}")
    
    if len(set(main_numbers)) != len(main_numbers):
        result["valid"] = False
        result["errors"].append("Num√©ros principaux en double d√©tect√©s")
    
    if len(set(stars)) != len(stars):
        result["valid"] = False
        result["errors"].append("√âtoiles en double d√©tect√©es")
    
    if not result["valid"]:
        return result
    
    # Calculate probability score
    if main_scores and star_scores:
        main_prob_sum = sum(main_scores.get(n, (n, 0))[1] if isinstance(main_scores.get(n), tuple) else main_scores.get(n, 0) for n in main_numbers)
        star_prob_sum = sum(star_scores.get(s, (s, 0))[1] if isinstance(star_scores.get(s), tuple) else star_scores.get(s, 0) for s in stars)
        result["probability"] = (main_prob_sum + star_prob_sum) / (MAIN_NUMBERS_COUNT + STAR_NUMBERS_COUNT)
        result["score"] = result["probability"] * 100
    
    # Check historical matches
    repo = get_repository()
    all_draws = repo.all_draws_df()
    
    for idx, row in all_draws.tail(100).iterrows():
        draw_main = [row['n1'], row['n2'], row['n3'], row['n4'], row['n5']]
        draw_stars = [row['s1'], row['s2']]
        
        main_matches = len(set(main_numbers) & set(draw_main))
        star_matches = len(set(stars) & set(draw_stars))
        
        if main_matches >= 3 or (main_matches >= 2 and star_matches >= 1):
            result["historical_matches"].append({
                "date": row['draw_date'],
                "main_matches": main_matches,
                "star_matches": star_matches
            })
    
    # Warnings and suggestions
    if all(n % 2 == 0 for n in main_numbers):
        result["warnings"].append("Tous les num√©ros sont pairs - tr√®s rare")
        result["suggestions"].append("Essayez un m√©lange de pairs et impairs")
    
    if all(n % 2 == 1 for n in main_numbers):
        result["warnings"].append("Tous les num√©ros sont impairs - tr√®s rare")
        result["suggestions"].append("Essayez un m√©lange de pairs et impairs")
    
    consecutive = sum(1 for i in range(len(sorted(main_numbers))-1) if sorted(main_numbers)[i+1] - sorted(main_numbers)[i] == 1)
    if consecutive >= 3:
        result["warnings"].append(f"{consecutive} num√©ros cons√©cutifs d√©tect√©s")
    
    return result

def get_hot_cold_numbers(n_draws: int = 50) -> dict:
    """Get hot and cold numbers from recent draws."""
    from repository import get_repository
    repo = get_repository()
    recent_draws = repo.all_draws_df().tail(n_draws)
    
    main_freq = Counter()
    star_freq = Counter()
    
    for _, row in recent_draws.iterrows():
        for i in range(1, 6):
            main_freq[row[f'n{i}']] += 1
        for i in range(1, 3):
            star_freq[row[f's{i}']] += 1
    
    hot_main = main_freq.most_common(10)
    cold_main = [(n, main_freq.get(n, 0)) for n in range(MAIN_NUM_MIN, MAIN_NUM_MAX + 1) if main_freq.get(n, 0) <= 2]
    
    hot_stars = star_freq.most_common(5)
    cold_stars = [(s, star_freq.get(s, 0)) for s in range(STAR_NUM_MIN, STAR_NUM_MAX + 1) if star_freq.get(s, 0) == 0]
    
    return {
        "hot_main": hot_main,
        "cold_main": sorted(cold_main, key=lambda x: x[1])[:10],
        "hot_stars": hot_stars,
        "cold_stars": cold_stars,
        "n_draws": n_draws
    }

def get_next_draw_info() -> dict:
    """Get information about the next EuroMillions draw."""
    # EuroMillions draws on Tuesday and Friday
    now = datetime.now()
    days_ahead = (1 - now.weekday()) % 7  # Tuesday = 1
    if days_ahead == 0 and now.hour >= 20:  # After 8 PM on Tuesday
        days_ahead = 7
    
    next_tuesday = now + timedelta(days=days_ahead)
    
    days_ahead_friday = (4 - now.weekday()) % 7  # Friday = 4
    if days_ahead_friday == 0 and now.hour >= 20:
        days_ahead_friday = 7
    
    next_friday = now + timedelta(days=days_ahead_friday)
    
    next_draw = min(next_tuesday, next_friday, key=lambda d: abs((d - now).total_seconds()))
    if next_draw < now:
        next_draw = max(next_tuesday, next_friday)
    
    time_until = next_draw - now
    
    return {
        "next_draw": next_draw,
        "days": time_until.days,
        "hours": time_until.seconds // 3600,
        "minutes": (time_until.seconds % 3600) // 60,
        "day_name": next_draw.strftime("%A"),
        "date_str": next_draw.strftime("%d/%m/%Y")
    }

def save_performance_tracking(prediction: dict):
    """Save a prediction for performance tracking."""
    tracking_file = Path("data/performance_tracking.json")
    tracking_file.parent.mkdir(exist_ok=True)
    
    predictions = []
    if tracking_file.exists():
        with open(tracking_file, 'r', encoding='utf-8') as f:
            predictions = json.load(f)
    
    predictions.append({
        **prediction,
        "id": hashlib.md5(json.dumps(prediction, sort_keys=True).encode()).hexdigest()[:8],
        "created_at": datetime.now().isoformat()
    })
    
    # Keep only last 100 predictions
    predictions = predictions[-100:]
    
    with open(tracking_file, 'w', encoding='utf-8') as f:
        json.dump(predictions, f, indent=2)

def load_performance_tracking() -> list:
    """Load performance tracking data."""
    tracking_file = Path("data/performance_tracking.json")
    if tracking_file.exists():
        with open(tracking_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    return []

def check_predictions_vs_draws() -> dict:
    """Check predictions against actual draws."""
    from repository import get_repository
    
    predictions = load_performance_tracking()
    repo = get_repository()
    all_draws = repo.all_draws_df()
    
    results = {
        "total_predictions": len(predictions),
        "checked": 0,
        "wins": [],
        "best_match": {"main": 0, "stars": 0},
        "total_matches": {"main": 0, "stars": 0}
    }
    
    for pred in predictions:
        if "tickets" not in pred:
            continue
        
        pred_date = datetime.fromisoformat(pred["created_at"]).date()
        
        for _, draw in all_draws.iterrows():
            draw_date = datetime.fromisoformat(draw['draw_date']).date()
            if draw_date >= pred_date:
                results["checked"] += 1
                draw_main = [draw['n1'], draw['n2'], draw['n3'], draw['n4'], draw['n5']]
                draw_stars = [draw['s1'], draw['s2']]
                
                for ticket in pred["tickets"]:
                    ticket_main = ticket.get('main') or ticket.get('balls', [])
                    ticket_stars = ticket.get('stars', [])
                    
                    main_matches = len(set(ticket_main) & set(draw_main))
                    star_matches = len(set(ticket_stars) & set(draw_stars))
                    
                    if main_matches >= 2:
                        results["wins"].append({
                            "date": draw['draw_date'],
                            "main_matches": main_matches,
                            "star_matches": star_matches,
                            "ticket": ticket
                        })
                    
                    if main_matches > results["best_match"]["main"]:
                        results["best_match"]["main"] = main_matches
                    if star_matches > results["best_match"]["stars"]:
                        results["best_match"]["stars"] = star_matches
                    
                    results["total_matches"]["main"] += main_matches
                    results["total_matches"]["stars"] += star_matches
                break
    
    return results

def generate_ticket_qr(ticket: dict) -> str:
    """Generate QR code data URL for a ticket."""
    try:
        import qrcode
        import io
        import base64
        
        ticket_data = f"EuroMillions: {ticket['balls'][0]}-{ticket['balls'][1]}-{ticket['balls'][2]}-{ticket['balls'][3]}-{ticket['balls'][4]} + {ticket['stars'][0]}-{ticket['stars'][1]}"
        
        qr = qrcode.QRCode(version=1, box_size=10, border=2)
        qr.add_data(ticket_data)
        qr.make(fit=True)
        
        img = qr.make_image(fill_color="black", back_color="white")
        
        buffer = io.BytesIO()
        img.save(buffer, format="PNG")
        buffer.seek(0)
        
        img_base64 = base64.b64encode(buffer.getvalue()).decode()
        return f"data:image/png;base64,{img_base64}"
    
    except ImportError:
        return None

def generate_pdf_tickets(tickets: list, method: str, seed: int) -> bytes:
    """Generate PDF with tickets."""
    try:
        from reportlab.lib.pagesizes import A4
        from reportlab.lib.units import mm
        from reportlab.pdfgen import canvas
        import io
        
        buffer = io.BytesIO()
        c = canvas.Canvas(buffer, pagesize=A4)
        width, height = A4
        
        # Title
        c.setFont("Helvetica-Bold", 20)
        c.drawString(50, height - 50, "EuroMillions - Tickets G√©n√©r√©s")
        
        c.setFont("Helvetica", 10)
        c.drawString(50, height - 70, f"Date: {datetime.now().strftime('%d/%m/%Y %H:%M')}")
        c.drawString(50, height - 85, f"M√©thode: {method} | Seed: {seed}")
        
        # Tickets
        y_pos = height - 120
        c.setFont("Helvetica-Bold", 12)
        
        for i, ticket in enumerate(tickets):
            if y_pos < 100:  # New page if needed
                c.showPage()
                y_pos = height - 50
            
            balls = ticket.get('balls') or ticket.get('main', [])
            stars = ticket.get('stars', [])
            
            # Ticket number
            c.setFont("Helvetica-Bold", 11)
            c.drawString(50, y_pos, f"Ticket #{i+1}")
            
            # Numbers
            c.setFont("Helvetica", 10)
            numbers_str = " - ".join(str(b) for b in balls)
            stars_str = " - ".join(str(s) for s in stars)
            
            c.drawString(150, y_pos, f"Num√©ros: {numbers_str}")
            c.drawString(400, y_pos, f"√âtoiles: {stars_str}")
            
            # Line separator
            y_pos -= 25
            c.line(50, y_pos, width - 50, y_pos)
            y_pos -= 15
        
        c.save()
        buffer.seek(0)
        return buffer.getvalue()
    
    except ImportError:
        return None

def format_tickets_display(tickets):
    """Format enhanced tickets for display with confidence scores."""
    if not tickets:
        return "Aucun ticket g√©n√©r√©"
    
    display_lines = []
    for ticket in tickets:
        balls_str = ticket['balls_str']
        stars_str = ticket['stars_str']
        
        # Get confidence info
        confidence = ticket.get('confidence', 50.0)
        confidence_level = ticket.get('confidence_level', 'Moyenne')
        method = ticket.get('method', 'unknown')
        
        # Choose confidence emoji
        if confidence >= 80:
            confidence_emoji = "üî•"
        elif confidence >= 65:
            confidence_emoji = "‚ö°"
        elif confidence >= 50:
            confidence_emoji = "‚ú®"
        else:
            confidence_emoji = "üí´"
        
        # Format with confidence and method info
        ticket_display = f"""üé´ **Ticket {ticket['ticket_id']}** {confidence_emoji}

   {balls_str}
   ‚≠ê {stars_str}
   
   üìä **Confiance:** {confidence}% ({confidence_level})
   üéØ **M√©thode:** {method}"""
        
        display_lines.append(ticket_display)
    
    return '\n\n---\n\n'.join(display_lines)


def _extract_probabilities(scores: dict, num_range: range) -> np.ndarray:
    """Extract probabilities from score dictionary handling both tuples and floats."""
    import numpy as np
    # Check first element to determine type
    first_val = scores[num_range[0]]
    if isinstance(first_val, tuple):
        return np.array([scores[i][1] for i in num_range])
    else:
        return np.array([scores[i] for i in num_range])

def _generate_hybrid_selection(probs: np.ndarray, top_k: int, select_k: int, nums_range: range) -> list:
    """Generate hybrid selection: top-K weighted random sampling."""
    import numpy as np
    top_idx = np.argsort(probs)[-top_k:]
    top_probs = probs[top_idx]
    top_probs_norm = (top_probs / top_probs.sum()).flatten()
    top_nums = (top_idx + 1).flatten()
    return sorted(np.random.choice(top_nums, size=select_k, replace=False, p=top_probs_norm).tolist())

def _generate_tickets_fast(n: int, method: str, seed: int, main_scores: dict, star_scores: dict) -> List[dict]:
    """
    G√©n√®re des tickets RAPIDEMENT en utilisant des probabilit√©s pr√©calcul√©es.
    √âvite le rechargement des mod√®les ML √† chaque appel.
    
    Args:
        n: Nombre de tickets
        method: M√©thode de g√©n√©ration
        seed: Graine al√©atoire
        main_scores: Probabilit√©s pr√©calcul√©es pour les num√©ros principaux {1:0.12, 2:0.08, ...}
        star_scores: Probabilit√©s pr√©calcul√©es pour les √©toiles {1:0.15, 2:0.09, ...}
    
    Returns:
        Liste de tickets {main: [1,2,3,4,5], stars: [1,2]}
    """
    import numpy as np
    
    # Input validation
    if n <= 0:
        raise ValueError(f"n must be positive, got {n}")
    if method not in ["topk", "random", "hybrid", "ensemble", "advanced_hybrid"]:
        raise ValueError(f"Unknown method: {method}")
    
    # Use RandomState for better reproducibility
    rng = np.random.RandomState(seed)
    tickets = []
    
    # Extract probabilities once (optimized)
    main_nums = list(range(MAIN_NUM_MIN, MAIN_NUM_MAX + 1))
    star_nums = list(range(STAR_NUM_MIN, STAR_NUM_MAX + 1))
    main_probs = _extract_probabilities(main_scores, main_nums)
    star_probs = _extract_probabilities(star_scores, star_nums)
    
    for i in range(n):
        if method == "topk":
            # Top-K d√©terministe
            top_main_idx = np.argsort(main_probs)[-MAIN_NUMBERS_COUNT:]
            top_star_idx = np.argsort(star_probs)[-STAR_NUMBERS_COUNT:]
            main = sorted((top_main_idx + 1).tolist())
            stars = sorted((top_star_idx + 1).tolist())
        
        elif method == "random":
            # Al√©atoire pond√©r√© par probabilit√©s
            main_probs_norm = main_probs / main_probs.sum()
            star_probs_norm = star_probs / star_probs.sum()
            main = sorted(rng.choice(main_nums, size=MAIN_NUMBERS_COUNT, replace=False, p=main_probs_norm).tolist())
            stars = sorted(rng.choice(star_nums, size=STAR_NUMBERS_COUNT, replace=False, p=star_probs_norm).tolist())
        
        elif method in ["hybrid", "ensemble", "advanced_hybrid"]:
            # Hybrid selection: top-K weighted random
            # Note: ensemble/advanced_hybrid use same fast approximation in backtesting
            main = _generate_hybrid_selection(main_probs, HYBRID_TOP_MAIN, MAIN_NUMBERS_COUNT, main_nums)
            stars = _generate_hybrid_selection(star_probs, HYBRID_TOP_STARS, STAR_NUMBERS_COUNT, star_nums)
        
        else:
            # Fallback: uniform random
            main = sorted(rng.choice(main_nums, size=MAIN_NUMBERS_COUNT, replace=False).tolist())
            stars = sorted(rng.choice(star_nums, size=STAR_NUMBERS_COUNT, replace=False).tolist())
        
        tickets.append({
            'main': main,
            'stars': stars
        })
    
    return tickets


def run_backtesting(seeds: List[int], methods: List[str], n_draws: int, n_tickets: int) -> pd.DataFrame:
    """
    Lance le backtesting OPTIMIS√â pour trouver les meilleures configurations.
    Pr√©calcule les probabilit√©s ML UNE SEULE FOIS au d√©but pour acc√©l√©rer drastiquement.
    
    Args:
        seeds: Liste des graines √† tester
        methods: Liste des m√©thodes √† tester
        n_draws: Nombre de tirages r√©cents √† utiliser
        n_tickets: Nombre de tickets par tirage
        
    Returns:
        DataFrame avec les r√©sultats
    """
    from repository import get_repository
    import train_models
    import time
    
    repo = get_repository()
    all_draws = repo.all_draws_df()
    test_draws = all_draws.tail(n_draws)
    
    # ====== PR√âPARATION DES DONN√âES ======
    # Convertir les colonnes n1-n5, s1-s2 en listes 'main' et 'stars' (vectorized)
    test_draws = test_draws.copy()
    test_draws['main'] = test_draws[['n1', 'n2', 'n3', 'n4', 'n5']].values.tolist()
    test_draws['stars'] = test_draws[['s1', 's2']].values.tolist()
    
    # V√©rification des donn√©es
    if len(test_draws) == 0:
        st.error("‚ùå Aucun tirage trouv√© dans la base de donn√©es !")
        return pd.DataFrame()
    
    st.info(f"üìä {len(test_draws)} tirages historiques charg√©s pour le backtesting")
    
    # Afficher un exemple de tirage pour v√©rification
    first_draw = test_draws.iloc[0]
    st.text(f"Exemple: {first_draw['main']} + {first_draw['stars']}")
    
    # ====== OPTIMISATION MAJEURE ======
    # Pr√©calculer les probabilit√©s ML UNE SEULE FOIS (au lieu de les recalculer des milliers de fois)
    status_precalc = st.empty()
    status_precalc.text("‚ö° Optimisation : Pr√©calcul des probabilit√©s ML (une seule fois)...")
    
    try:
        # Utiliser le cache Streamlit pour les probabilit√©s
        main_scores, star_scores = _get_cached_probabilities()
        status_precalc.text("‚úÖ Probabilit√©s ML charg√©es depuis le cache")
        time.sleep(0.5)
        status_precalc.empty()
    except Exception as e:
        status_precalc.text(f"‚ö†Ô∏è Erreur lors du chargement des probabilit√©s: {str(e)}")
        import traceback
        st.error(traceback.format_exc())
        main_scores = None
        star_scores = None
    
    results = []
    total_tests = len(seeds) * len(methods)
    progress_bar = st.progress(0)
    status_text = st.empty()
    current_test = 0
    start_time = time.time()
    
    for seed in seeds:
        for method in methods:
            current_test += 1
            progress_pct = current_test / total_tests
            progress_bar.progress(progress_pct)
            
            # Calculate ETA
            elapsed = time.time() - start_time
            if current_test > 1:
                eta_seconds = (elapsed / (current_test - 1)) * (total_tests - current_test)
                eta_str = f" | ETA: {int(eta_seconds)}s"
            else:
                eta_str = ""
            
            status_text.text(f"‚ö° Test {current_test}/{total_tests} ({progress_pct*100:.1f}%): seed={seed}, method={method}{eta_str}")
            
            total_main_matches = 0
            total_star_matches = 0
            total_score = 0
            best_result = {'main': 0, 'stars': 0}
            jackpot_count = 0
            rank2_count = 0
            rank3_count = 0
            any_win_count = 0
            
            for idx, actual_draw in test_draws.iterrows():
                try:
                    # ====== G√âN√âRATION OPTIMIS√âE ======
                    # IMPORTANT: Pour le backtesting, TOUTES les m√©thodes utilisent _generate_tickets_fast
                    # avec les probabilit√©s pr√©calcul√©es pour √©viter de prendre des heures
                    # Les m√©thodes ensemble/advanced_hybrid utiliseront une approximation rapide
                    if main_scores and star_scores:
                        tickets = _generate_tickets_fast(n_tickets, method, seed, main_scores, star_scores)
                    else:
                        # Fallback si pr√©calcul impossible (ne devrait jamais arriver)
                        tickets = suggest_tickets_ui(
                            n=n_tickets,
                            method=method,
                            seed=seed,
                            use_ensemble=False
                        )
                    
                    # CORRECTIF: Extraire les num√©ros du DataFrame (colonnes n1-n5, s1-s2)
                    actual_main = [actual_draw['n1'], actual_draw['n2'], actual_draw['n3'], 
                                   actual_draw['n4'], actual_draw['n5']]
                    actual_stars = [actual_draw['s1'], actual_draw['s2']]
                    
                    # √âvaluer chaque ticket
                    for ticket in tickets:
                        # Normaliser la structure: 'balls' ou 'main' pour les num√©ros principaux
                        ticket_main = ticket.get('main') or ticket.get('balls', [])
                        ticket_stars = ticket.get('stars', [])
                        
                        main_matches = len(set(ticket_main) & set(actual_main))
                        star_matches = len(set(ticket_stars) & set(actual_stars))
                        
                        total_main_matches += main_matches
                        total_star_matches += star_matches
                        score = main_matches * SCORE_MAIN_WEIGHT + star_matches * SCORE_STAR_WEIGHT
                        total_score += score
                        
                        # Meilleur r√©sultat
                        if (main_matches > best_result['main'] or 
                            (main_matches == best_result['main'] and star_matches > best_result['stars'])):
                            best_result = {'main': main_matches, 'stars': star_matches}
                        
                        # Compter les gains
                        if main_matches == 5 and star_matches == 2:
                            jackpot_count += 1
                        elif main_matches == 5 and star_matches == 1:
                            rank2_count += 1
                        elif main_matches == 5 and star_matches == 0:
                            rank3_count += 1
                        
                        if main_matches >= 2 or star_matches >= 1:
                            any_win_count += 1
                            
                except Exception as e:
                    # Log detailed error information for debugging
                    import traceback
                    error_msg = f"‚ùå Erreur configuration: seed={seed}, method={method}, tirage={idx}"
                    error_detail = f"Type: {type(e).__name__}, Message: {str(e)}"
                    st.warning(f"{error_msg}\n{error_detail}")
                    # Print full traceback to console for developers
                    print(f"\n{'='*60}")
                    print(error_msg)
                    print(error_detail)
                    print(traceback.format_exc())
                    print('='*60)
                    continue
            
            n_total_tickets = n_draws * n_tickets
            
            results.append({
                'seed': seed,
                'method': method,
                'avg_score': total_score / n_total_tickets if n_total_tickets > 0 else 0,
                'avg_main': total_main_matches / n_total_tickets if n_total_tickets > 0 else 0,
                'avg_stars': total_star_matches / n_total_tickets if n_total_tickets > 0 else 0,
                'best_main': best_result['main'],
                'best_stars': best_result['stars'],
                'jackpots': jackpot_count,
                'rank2': rank2_count,
                'rank3': rank3_count,
                'any_win': any_win_count,
                'win_rate': (any_win_count / n_total_tickets * 100) if n_total_tickets > 0 else 0
            })
    
    progress_bar.empty()
    status_text.empty()
    
    df_results = pd.DataFrame(results)
    df_results = df_results.sort_values('avg_score', ascending=False)
    
    return df_results


def main():
    """Main Streamlit application."""
    
    # Title and header
    st.title("üé≤ EuroMillions ‚Äî Console Graphique")
    st.markdown("Interface de gestion compl√®te pour le syst√®me de pr√©diction EuroMillions")
    
    # Smart Suggestions Engine
    try:
        from repository import get_repository
        repo = get_repository()
        all_draws = repo.all_draws_df()
        
        suggestions = []
        
        # Check data freshness
        if not all_draws.empty:
            last_draw_date = datetime.fromisoformat(all_draws.iloc[-1]['draw_date'])
            days_since = (datetime.now() - last_draw_date).days
            
            if days_since > 7:
                suggestions.append({
                    "type": "warning",
                    "icon": "‚ö†Ô∏è",
                    "text": f"Donn√©es obsol√®tes ({days_since} jours) - Rafra√Æchissez depuis la FDJ",
                    "action": "Scroller vers 'Scraping FDJ'"
                })
            elif days_since <= 1:
                suggestions.append({
                    "type": "success",
                    "icon": "‚úÖ",
                    "text": "Donn√©es √† jour! Pr√™t pour de nouvelles pr√©dictions",
                    "action": None
                })
        
        # Check model status
        model_file = Path("models/main_model.pkl")
        if model_file.exists():
            model_age_days = (datetime.now() - datetime.fromtimestamp(model_file.stat().st_mtime)).days
            if model_age_days > 30:
                suggestions.append({
                    "type": "info",
                    "icon": "üîÑ",
                    "text": f"Mod√®les entra√Æn√©s il y a {model_age_days} jours - R√©entra√Ænement recommand√©",
                    "action": "Section 'Entra√Ænement ML'"
                })
        else:
            suggestions.append({
                "type": "error",
                "icon": "‚ùå",
                "text": "Mod√®les ML non entra√Æn√©s - Entra√Ænez avant de g√©n√©rer des tickets",
                "action": "Allez √† 'Entra√Ænement ML'"
            })
        
        # Check backtesting results
        if len(all_draws) >= 50:
            suggestions.append({
                "type": "info",
                "icon": "üî¨",
                "text": "Assez de donn√©es pour un backtesting complet - Testez vos configurations",
                "action": "Section 'Backtesting'"
            })
        
        # Check hot numbers
        hot_cold = get_hot_cold_numbers(20)
        if hot_cold["hot_main"]:
            hot_nums = [str(n[0]) for n in hot_cold["hot_main"][:3]]
            suggestions.append({
                "type": "success",
                "icon": "üî•",
                "text": f"Num√©ros chauds actuels: {', '.join(hot_nums)}",
                "action": "Voir 'Analyse Historique'"
            })
        
        # Display suggestions
        if suggestions:
            for sug in suggestions[:3]:  # Show max 3 suggestions
                if sug["type"] == "warning":
                    st.warning(f"{sug['icon']} {sug['text']}")
                elif sug["type"] == "error":
                    st.error(f"{sug['icon']} {sug['text']}")
                elif sug["type"] == "success":
                    st.success(f"{sug['icon']} {sug['text']}")
                else:
                    st.info(f"{sug['icon']} {sug['text']}")
    
    except Exception as e:
        pass  # Silently fail - suggestions are non-critical
    
    st.markdown("---")
    
    # Sidebar configuration
    with st.sidebar:
        # Draw countdown
        next_draw = get_next_draw_info()
        st.markdown(f"### üé∞ Prochain tirage")
        st.info(f"**{next_draw['day_name']} {next_draw['date_str']}**")
        if next_draw['days'] == 0:
            st.markdown(f"‚è∞ Dans **{next_draw['hours']}h {next_draw['minutes']}min**")
        else:
            st.markdown(f"üìÖ Dans **{next_draw['days']} jours**")
        
        st.markdown("---")
        
        # Configuration Presets
        st.header("üíæ Pr√©r√©glages")
        presets = load_config_presets()
        
        if presets:
            preset_names = list(presets.keys())
            selected_preset = st.selectbox(
                "Charger une configuration",
                ["-- Nouveau --"] + preset_names,
                key="preset_selector"
            )
            
            col1, col2 = st.columns(2)
            with col1:
                if selected_preset != "-- Nouveau --" and st.button("üì• Charger", use_container_width=True):
                    preset_config = presets[selected_preset]
                    st.session_state.update(preset_config)
                    st.success(f"‚úÖ {selected_preset} charg√©!")
                    st.rerun()
            
            with col2:
                if selected_preset != "-- Nouveau --" and st.button("üóëÔ∏è Supprimer", use_container_width=True):
                    delete_config_preset(selected_preset)
                    st.success("Supprim√©!")
                    st.rerun()
        
        st.markdown("---")
        
        st.header("üéØ Suggestions")
        
        # Suggestion parameters
        n_tickets = st.slider(
            "Nombre de tickets",
            min_value=1,
            max_value=20,
            value=10,
            help="Nombre de combinaisons √† g√©n√©rer"
        )
        
        method = st.selectbox(
            "M√©thode de g√©n√©ration",
            options=["hybrid", "ensemble", "advanced_hybrid", "topk", "random"],
            index=0,
            help="Strat√©gie de s√©lection des num√©ros"
        )
        
        # Advanced options
        st.subheader("üîß Options avanc√©es")
        
        use_ensemble = st.checkbox(
            "Utiliser les mod√®les d'ensemble",
            value=True,
            help="Combine plusieurs algorithmes ML pour de meilleures pr√©dictions"
        )
        
        # Hybrid strategy weights (only for advanced_hybrid)
        if method == "advanced_hybrid":
            st.subheader("‚öñÔ∏è Poids de la strat√©gie hybride")
            
            col1, col2 = st.columns(2)
            with col1:
                ml_weight = st.slider("ML", 0.0, 1.0, 0.4, 0.1, help="Poids des pr√©dictions ML")
                freq_weight = st.slider("Fr√©quence", 0.0, 1.0, 0.3, 0.1, help="Poids de l'analyse de fr√©quence")
            
            with col2:
                pattern_weight = st.slider("Motifs", 0.0, 1.0, 0.2, 0.1, help="Poids de l'analyse des motifs")
                gap_weight = st.slider("√âcarts", 0.0, 1.0, 0.1, 0.1, help="Poids de l'analyse des √©carts")
            
            # Normalize weights
            total_weight = ml_weight + freq_weight + pattern_weight + gap_weight
            if total_weight > 0:
                hybrid_weights = {
                    "ml_weight": ml_weight / total_weight,
                    "freq_weight": freq_weight / total_weight,
                    "pattern_weight": pattern_weight / total_weight,
                    "gap_weight": gap_weight / total_weight
                }
            else:
                hybrid_weights = None
        else:
            hybrid_weights = None
        
        seed = st.number_input(
            "Graine al√©atoire",
            min_value=1,
            max_value=9999,
            value=42,
            help="Pour reproductibilit√© des r√©sultats"
        )
        
        st.markdown("---")
        
        # Settings expander
        with st.expander("‚öôÔ∏è Param√®tres (.env)"):
            st.subheader("Configuration syst√®me")
            
            # Load current settings
            current_settings = load_env_settings()
            
            # Settings form
            with st.form("env_settings"):
                new_settings = {}
                
                new_settings["STORAGE_DIR"] = st.text_input(
                    "R√©pertoire de stockage",
                    value=current_settings["STORAGE_DIR"],
                    help="Dossier pour les donn√©es"
                )
                
                new_settings["DB_URL"] = st.text_input(
                    "URL de base de donn√©es",
                    value=current_settings["DB_URL"],
                    help="Chemin vers la base SQLite"
                )
                
                new_settings["USER_AGENT"] = st.text_input(
                    "User Agent",
                    value=current_settings["USER_AGENT"],
                    help="Identification pour les requ√™tes web"
                )
                
                new_settings["REQUEST_TIMEOUT"] = st.text_input(
                    "Timeout requ√™tes (sec)",
                    value=current_settings["REQUEST_TIMEOUT"],
                    help="D√©lai d'attente des requ√™tes"
                )
                
                new_settings["MAX_RETRIES"] = st.text_input(
                    "Nombre de tentatives",
                    value=current_settings["MAX_RETRIES"],
                    help="Retries en cas d'√©chec"
                )
                
                if st.form_submit_button("üíæ Enregistrer param√®tres"):
                    try:
                        save_env_settings(new_settings)
                        st.success("‚úÖ Param√®tres sauvegard√©s dans .env")
                        st.rerun()
                    except Exception as e:
                        st.error(f"‚ùå Erreur lors de la sauvegarde: {e}")
    
    # Main content sections
    
    # Section 1: Initialization & Updates
    st.header("üîß Initialisation & Mise √† jour")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üì• T√©l√©charger l'historique & Initialiser", use_container_width=True):
            with st.spinner("T√©l√©chargement de l'historique complet..."):
                try:
                    result = init_full_history()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        st.json(result)
                    else:
                        st.error(f"‚ùå {result['message']}")
                        st.json(result)
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de l'initialisation: {e}")
    
    with col2:
        if st.button("üîÑ Mettre √† jour (derniers tirages)", use_container_width=True):
            with st.spinner("Mise √† jour des derniers tirages..."):
                try:
                    result = update_incremental()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        st.json(result)
                    else:
                        st.error(f"‚ùå {result['message']}")
                        st.json(result)
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de la mise √† jour: {e}")
    
    st.markdown("---")
    
    # Section 2: Training
    st.header("üß† Entra√Ænement")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üèãÔ∏è Entra√Æner (from scratch)", use_container_width=True):
            with st.spinner("Entra√Ænement des mod√®les en cours..."):
                try:
                    result = train_from_scratch()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        
                        # Display training metrics
                        metrics_col1, metrics_col2 = st.columns(2)
                        with metrics_col1:
                            if result.get("main_logloss"):
                                st.metric("Log-loss boules principales", f"{result['main_logloss']:.4f}")
                        with metrics_col2:
                            if result.get("star_logloss"):
                                st.metric("Log-loss √©toiles", f"{result['star_logloss']:.4f}")
                        
                        if result.get("training_data_size"):
                            st.info(f"üìä Donn√©es d'entra√Ænement: {result['training_data_size']} tirages")
                    else:
                        st.error(f"‚ùå {result['message']}")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de l'entra√Ænement: {e}")
    
    with col2:
        if st.button("ü§ñ Ensemble de mod√®les", use_container_width=True):
            with st.spinner("Entra√Ænement des mod√®les d'ensemble..."):
                try:
                    result = train_ensemble_models()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        
                        if result.get("models_trained"):
                            st.info(f"üéØ Mod√®les entra√Æn√©s: {', '.join(result['models_trained'])}")
                        
                        if result.get("performance"):
                            perf = result["performance"]
                            metrics_col1, metrics_col2 = st.columns(2)
                            with metrics_col1:
                                if "ensemble_score" in perf:
                                    st.metric("Score d'ensemble", f"{perf['ensemble_score']:.4f}")
                            with metrics_col2:
                                if "best_model" in perf:
                                    st.metric("Meilleur mod√®le", perf["best_model"])
                    else:
                        st.warning(f"‚ö†Ô∏è {result['message']}")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de l'entra√Ænement d'ensemble: {e}")
    
    with col3:
        if st.button("üì¶ Recharger le mod√®le", use_container_width=True):
            with st.spinner("Rechargement du mod√®le..."):
                try:
                    result = reload_models()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        
                        if result.get("trained_at"):
                            st.info(f"üìÖ Entra√Æn√© le: {result['trained_at']}")
                    else:
                        st.error(f"‚ùå {result['message']}")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors du rechargement: {e}")
    
    st.markdown("---")
    
    # Section 3: Current Probabilities
    st.header("üìä Probabilit√©s actuelles")
    
    if st.button("üîÑ Actualiser les probabilit√©s"):
        with st.spinner("Calcul des probabilit√©s..."):
            try:
                balls_df, stars_df = get_scores()
                
                if not balls_df.empty and not stars_df.empty:
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.subheader("üé± Top 15 boules principales")
                        top_balls = balls_df.head(15)
                        st.dataframe(
                            top_balls[['ball', 'percentage', 'rank']].rename(columns={
                                'ball': 'Boule',
                                'percentage': 'Probabilit√© (%)',
                                'rank': 'Rang'
                            }),
                            use_container_width=True,
                            hide_index=True
                        )
                    
                    with col2:
                        st.subheader("‚≠ê Top 5 √©toiles")
                        top_stars = stars_df.head(5)
                        st.dataframe(
                            top_stars[['star', 'percentage', 'rank']].rename(columns={
                                'star': '√âtoile',
                                'percentage': 'Probabilit√© (%)',
                                'rank': 'Rang'
                            }),
                            use_container_width=True,
                            hide_index=True
                        )
                else:
                    st.warning("‚ö†Ô∏è Aucune probabilit√© disponible. Entra√Ænez d'abord un mod√®le.")
                    
            except Exception as e:
                st.error(f"‚ùå Erreur lors du calcul des probabilit√©s: {e}")
    
    st.markdown("---")
    
    # Section 3.2: Historical Analysis Dashboard
    st.header("üìä Analyse Historique")
    
    analysis_type = st.radio(
        "Type d'analyse",
        ["üî• Num√©ros Chauds/Froids", "üìà Distribution", "üîç Patterns"],
        horizontal=True
    )
    
    if analysis_type == "üî• Num√©ros Chauds/Froids":
        period = st.select_slider(
            "P√©riode d'analyse",
            options=[10, 20, 50, 100, 200],
            value=50,
            format_func=lambda x: f"Derniers {x} tirages"
        )
        
        if st.button("üîç Analyser", use_container_width=True):
            with st.spinner("Analyse en cours..."):
                hot_cold = get_hot_cold_numbers(period)
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("üî• Num√©ros CHAUDS")
                    st.caption(f"Plus fr√©quents sur {period} tirages")
                    
                    hot_main_df = pd.DataFrame(hot_cold["hot_main"], columns=["Num√©ro", "Fr√©quence"])
                    hot_main_df["Taux %"] = (hot_main_df["Fr√©quence"] / period * 100).round(1)
                    st.dataframe(hot_main_df, use_container_width=True, hide_index=True)
                    
                    st.caption("‚≠ê √âtoiles chaudes")
                    hot_stars_df = pd.DataFrame(hot_cold["hot_stars"], columns=["√âtoile", "Fr√©quence"])
                    st.dataframe(hot_stars_df, use_container_width=True, hide_index=True)
                
                with col2:
                    st.subheader("‚ùÑÔ∏è Num√©ros FROIDS")
                    st.caption("Moins fr√©quents - potentiel de retour")
                    
                    cold_main_df = pd.DataFrame(hot_cold["cold_main"], columns=["Num√©ro", "Fr√©quence"])
                    st.dataframe(cold_main_df, use_container_width=True, hide_index=True)
                    
                    if hot_cold["cold_stars"]:
                        st.caption("‚≠ê √âtoiles froides")
                        cold_stars_df = pd.DataFrame(hot_cold["cold_stars"], columns=["√âtoile", "Fr√©quence"])
                        st.dataframe(cold_stars_df, use_container_width=True, hide_index=True)
                    else:
                        st.info("Toutes les √©toiles sont apparues r√©cemment")
    
    elif analysis_type == "üìà Distribution":
        from repository import get_repository
        repo = get_repository()
        recent_draws = repo.all_draws_df().tail(100)
        
        # Odd/Even analysis
        odd_count = 0
        even_count = 0
        
        for _, row in recent_draws.iterrows():
            for i in range(1, 6):
                if row[f'n{i}'] % 2 == 0:
                    even_count += 1
                else:
                    odd_count += 1
        
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Pairs", f"{even_count} ({even_count/(even_count+odd_count)*100:.1f}%)")
        with col2:
            st.metric("Impairs", f"{odd_count} ({odd_count/(even_count+odd_count)*100:.1f}%)")
        
        st.info("üí° Distribution √©quilibr√©e id√©ale : ~50% pairs, ~50% impairs")
    
    else:  # Patterns
        st.info("üîç Analyse des patterns communes")
        from repository import get_repository
        repo = get_repository()
        recent_draws = repo.all_draws_df().tail(50)
        
        consecutive_count = 0
        for _, row in recent_draws.iterrows():
            nums = sorted([row['n1'], row['n2'], row['n3'], row['n4'], row['n5']])
            for i in range(len(nums)-1):
                if nums[i+1] - nums[i] == 1:
                    consecutive_count += 1
        
        st.metric("Num√©ros cons√©cutifs", f"{consecutive_count} occurrences", f"{consecutive_count/50:.1f} par tirage")
        st.caption("Moyenne dans les 50 derniers tirages")
    
    st.markdown("---")
    
    # Section 3.5: Backtesting - Optimisation des param√®tres
    st.header("üî¨ Backtesting - Optimisation des param√®tres")
    
    with st.expander("‚ÑπÔ∏è Qu'est-ce que le backtesting?", expanded=False):
        st.markdown("""
        **Le backtesting permet de tester diff√©rentes configurations** (graines + m√©thodes) 
        sur les tirages pass√©s pour identifier lesquelles auraient donn√© les meilleurs r√©sultats.
        
        **Pourquoi c'est utile:**
        - üéØ Trouve la **meilleure graine** automatiquement
        - üìä Compare objectivement les **diff√©rentes m√©thodes**
        - üîç Analyse les performances sur les **tirages r√©els**
        - üí° Vous dit **exactement quels param√®tres** utiliser
        
        **Note:** Les performances pass√©es ne garantissent pas les r√©sultats futurs, 
        mais permettent d'optimiser vos choix de mani√®re scientifique.
        """)
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üé≤ Graines √† tester")
        seed_option = st.radio(
            "Plage de graines",
            options=["Rapide (10 graines)", "Standard (25 graines)", "Complet (50 graines)", "Personnalis√©"],
            index=1
        )
        
        if seed_option == "Rapide (10 graines)":
            seeds_to_test = [1, 10, 20, 30, 40, 42, 50, 75, 100, 150]
        elif seed_option == "Standard (25 graines)":
            seeds_to_test = list(range(1, 26))
        elif seed_option == "Complet (50 graines)":
            seeds_to_test = list(range(1, 51))
        else:  # Personnalis√©
            seed_start = st.number_input("Graine de d√©but", min_value=1, max_value=9999, value=1)
            seed_end = st.number_input("Graine de fin", min_value=1, max_value=9999, value=50)
            seeds_to_test = list(range(seed_start, seed_end + 1))
        
        st.caption(f"üìä {len(seeds_to_test)} graines √† tester")
    
    with col2:
        st.subheader("üéØ M√©thodes √† tester")
        methods_to_test = st.multiselect(
            "S√©lectionnez les m√©thodes",
            options=["topk", "random", "hybrid", "ensemble", "advanced_hybrid"],
            default=["topk", "random", "hybrid"]
        )
        
        if not methods_to_test:
            st.warning("‚ö†Ô∏è S√©lectionnez au moins une m√©thode")
        
        # Avertissement pour ensemble/advanced_hybrid
        if "ensemble" in methods_to_test or "advanced_hybrid" in methods_to_test:
            st.info("‚ÑπÔ∏è **Note:** Les m√©thodes ensemble/advanced_hybrid utilisent une approximation rapide dans le backtesting (similaire √† hybrid) pour √©viter des temps d'ex√©cution de plusieurs heures.")
    
    col3, col4 = st.columns(2)
    
    with col3:
        n_draws_backtest = st.slider(
            "Nombre de tirages √† analyser",
            min_value=10,
            max_value=100,
            value=30,
            help="Plus = plus pr√©cis mais plus lent"
        )
    
    with col4:
        n_tickets_backtest = st.slider(
            "Tickets par tirage",
            min_value=5,
            max_value=20,
            value=10,
            help="Nombre de tickets g√©n√©r√©s pour chaque test"
        )
    
    # Estimation du temps
    total_tests = len(seeds_to_test) * len(methods_to_test)
    estimated_time = total_tests * 0.5  # ~0.5 sec par test
    
    st.info(f"‚è±Ô∏è Tests √† effectuer: **{total_tests}** | Dur√©e estim√©e: **~{estimated_time/60:.1f} minutes**")
    
    if st.button("üöÄ Lancer le backtesting", use_container_width=True, type="primary"):
        if not methods_to_test:
            st.error("‚ùå Veuillez s√©lectionner au moins une m√©thode")
        else:
            with st.spinner(f"Backtesting en cours... ({total_tests} tests)"):
                try:
                    df_results = run_backtesting(
                        seeds=seeds_to_test,
                        methods=methods_to_test,
                        n_draws=n_draws_backtest,
                        n_tickets=n_tickets_backtest
                    )
                    
                    if not df_results.empty:
                        st.success("‚úÖ Backtesting termin√©!")
                        
                        # Afficher le TOP 10
                        st.subheader("üèÜ TOP 10 Meilleures Configurations")
                        
                        top_10 = df_results.head(10).copy()
                        top_10['rank'] = range(1, len(top_10) + 1)
                        
                        # Formater pour l'affichage
                        display_df = top_10[[
                            'rank', 'seed', 'method', 'avg_score', 'avg_main', 
                            'avg_stars', 'best_main', 'best_stars', 'win_rate'
                        ]].copy()
                        
                        display_df.columns = [
                            'Rang', 'Graine', 'M√©thode', 'Score Moy', 'Nums Moy', 
                            '√âtoiles Moy', 'Meilleur Nums', 'Meilleur √âtoiles', 'Taux Gain %'
                        ]
                        
                        # Arrondir les valeurs
                        display_df['Score Moy'] = display_df['Score Moy'].round(2)
                        display_df['Nums Moy'] = display_df['Nums Moy'].round(2)
                        display_df['√âtoiles Moy'] = display_df['√âtoiles Moy'].round(2)
                        display_df['Taux Gain %'] = display_df['Taux Gain %'].round(1)
                        
                        st.dataframe(
                            display_df,
                            use_container_width=True,
                            hide_index=True
                        )
                        
                        # Recommandation
                        best_config = df_results.iloc[0]
                        st.success(f"""
                        üí° **RECOMMANDATION:**
                        
                        Utilisez **seed={int(best_config['seed'])}** avec la m√©thode **{best_config['method']}**
                        
                        Cette configuration a obtenu:
                        - Score moyen: **{best_config['avg_score']:.2f}**
                        - Num√©ros corrects (moy): **{best_config['avg_main']:.2f}/5**
                        - √âtoiles correctes (moy): **{best_config['avg_stars']:.2f}/2**
                        - Meilleur r√©sultat: **{int(best_config['best_main'])} num√©ros + {int(best_config['best_stars'])} √©toiles**
                        - Taux de gain: **{best_config['win_rate']:.1f}%**
                        """)
                        
                        # Graphique de comparaison des m√©thodes
                        st.subheader("üìä Comparaison des m√©thodes")
                        
                        method_comparison = df_results.groupby('method').agg({
                            'avg_score': 'mean',
                            'avg_main': 'mean',
                            'avg_stars': 'mean',
                            'win_rate': 'mean'
                        }).round(2)
                        
                        st.bar_chart(method_comparison['avg_score'])
                        
                        # Export des r√©sultats
                        st.subheader("üíæ Export des r√©sultats")
                        
                        csv_data = df_results.to_csv(index=False)
                        st.download_button(
                            label="üì• T√©l√©charger les r√©sultats (CSV)",
                            data=csv_data,
                            file_name=f"backtest_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                            mime="text/csv",
                            use_container_width=True
                        )
                        
                        # D√©tails par graine pour la meilleure m√©thode
                        if len(methods_to_test) > 1:
                            st.subheader("üîç D√©tails par graine (meilleure m√©thode)")
                            best_method = best_config['method']
                            method_details = df_results[df_results['method'] == best_method].head(10)
                            
                            st.line_chart(
                                method_details.set_index('seed')['avg_score'],
                                use_container_width=True
                            )
                    else:
                        st.warning("‚ö†Ô∏è Aucun r√©sultat obtenu")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors du backtesting: {e}")
                    import traceback
                    st.code(traceback.format_exc())
    
    st.markdown("---")
    
    # Section 3.7: A/B Testing Mode
    st.header("üß™ Mode Test A/B")
    
    with st.expander("‚ö° Comparer deux configurations", expanded=False):
        st.markdown("Testez et comparez deux m√©thodes c√¥te √† c√¥te pour identifier la plus performante")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("üÖ∞Ô∏è Configuration A")
            method_a = st.selectbox(
                "M√©thode A",
                options=["hybrid", "ensemble", "advanced_hybrid", "topk", "random"],
                index=0,
                key="ab_method_a"
            )
            seed_a = st.number_input("Seed A", min_value=1, max_value=9999, value=42, key="ab_seed_a")
        
        with col2:
            st.subheader("üÖ±Ô∏è Configuration B")
            method_b = st.selectbox(
                "M√©thode B",
                options=["hybrid", "ensemble", "advanced_hybrid", "topk", "random"],
                index=1,
                key="ab_method_b"
            )
            seed_b = st.number_input("Seed B", min_value=1, max_value=9999, value=123, key="ab_seed_b")
        
        n_tickets_ab = st.slider("Nombre de tickets par configuration", 10, 100, 50, 10)
        
        if st.button("‚ñ∂Ô∏è Lancer le test A/B", type="primary", use_container_width=True):
            with st.spinner("Ex√©cution du test A/B..."):
                try:
                    from repository import get_repository
                    repo = get_repository()
                    all_draws = repo.all_draws_df()
                    
                    if len(all_draws) < 30:
                        st.warning("‚ö†Ô∏è Pas assez de donn√©es pour un test significatif (minimum 30 tirages)")
                    else:
                        # Split data: train on first 80%, test on last 20%
                        split_idx = int(len(all_draws) * 0.8)
                        test_draws = all_draws.iloc[split_idx:].copy()
                        
                        main_scores, star_scores = _get_cached_probabilities()
                        
                        results_a = {"wins": 0, "total_main": 0, "total_stars": 0, "best_match": (0, 0)}
                        results_b = {"wins": 0, "total_main": 0, "total_stars": 0, "best_match": (0, 0)}
                        
                        # Generate tickets for both configs
                        tickets_a = _generate_tickets_fast(n_tickets_ab, method_a, seed_a, main_scores, star_scores)
                        tickets_b = _generate_tickets_fast(n_tickets_ab, method_b, seed_b, main_scores, star_scores)
                        
                        # Test against each draw
                        for _, draw in test_draws.iterrows():
                            draw_main = [draw['n1'], draw['n2'], draw['n3'], draw['n4'], draw['n5']]
                            draw_stars = [draw['s1'], draw['s2']]
                            
                            # Check config A
                            for ticket in tickets_a:
                                ticket_main = ticket.get('main') or ticket.get('balls', [])
                                ticket_stars = ticket.get('stars', [])
                                
                                main_match = len(set(ticket_main) & set(draw_main))
                                star_match = len(set(ticket_stars) & set(draw_stars))
                                
                                results_a["total_main"] += main_match
                                results_a["total_stars"] += star_match
                                
                                if main_match >= 2:
                                    results_a["wins"] += 1
                                
                                if (main_match, star_match) > results_a["best_match"]:
                                    results_a["best_match"] = (main_match, star_match)
                            
                            # Check config B
                            for ticket in tickets_b:
                                ticket_main = ticket.get('main') or ticket.get('balls', [])
                                ticket_stars = ticket.get('stars', [])
                                
                                main_match = len(set(ticket_main) & set(draw_main))
                                star_match = len(set(ticket_stars) & set(draw_stars))
                                
                                results_b["total_main"] += main_match
                                results_b["total_stars"] += star_match
                                
                                if main_match >= 2:
                                    results_b["wins"] += 1
                                
                                if (main_match, star_match) > results_b["best_match"]:
                                    results_b["best_match"] = (main_match, star_match)
                        
                        # Display results
                        st.success(f"‚úÖ Test compl√©t√© sur {len(test_draws)} tirages")
                        
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            st.subheader("üÖ∞Ô∏è R√©sultats A")
                            st.metric("Gains (2+)", results_a["wins"])
                            st.metric("Meilleur match", f"{results_a['best_match'][0]}+{results_a['best_match'][1]}")
                            avg_main_a = results_a["total_main"] / (n_tickets_ab * len(test_draws))
                            avg_stars_a = results_a["total_stars"] / (n_tickets_ab * len(test_draws))
                            st.caption(f"Moy: {avg_main_a:.2f} num + {avg_stars_a:.2f} √©toiles")
                        
                        with col2:
                            st.subheader("üÖ±Ô∏è R√©sultats B")
                            st.metric("Gains (2+)", results_b["wins"])
                            st.metric("Meilleur match", f"{results_b['best_match'][0]}+{results_b['best_match'][1]}")
                            avg_main_b = results_b["total_main"] / (n_tickets_ab * len(test_draws))
                            avg_stars_b = results_b["total_stars"] / (n_tickets_ab * len(test_draws))
                            st.caption(f"Moy: {avg_main_b:.2f} num + {avg_stars_b:.2f} √©toiles")
                        
                        # Determine winner
                        score_a = results_a["wins"] * 10 + avg_main_a * 5 + avg_stars_a * 3
                        score_b = results_b["wins"] * 10 + avg_main_b * 5 + avg_stars_b * 3
                        
                        if score_a > score_b:
                            st.success(f"üèÜ Configuration A gagne avec un score de {score_a:.1f} vs {score_b:.1f}")
                        elif score_b > score_a:
                            st.success(f"üèÜ Configuration B gagne avec un score de {score_b:.1f} vs {score_a:.1f}")
                        else:
                            st.info("ü§ù Match nul - performances √©quivalentes")
                
                except Exception as e:
                    st.error(f"‚ùå Erreur lors du test A/B: {e}")
                    import traceback
                    st.code(traceback.format_exc())
    
    st.markdown("---")
    
    # Section 3.8: Smart Ticket Validator
    st.header("üé≤ Validateur de Ticket Intelligent")
    
    with st.expander("‚úèÔ∏è Valider votre ticket personnel", expanded=False):
        st.markdown("Entrez vos num√©ros pour obtenir une analyse compl√®te")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("Num√©ros principaux (5)")
            user_main = []
            cols = st.columns(5)
            for i in range(5):
                with cols[i]:
                    num = st.number_input(f"N{i+1}", min_value=1, max_value=50, value=1+i*10, key=f"user_main_{i}")
                    user_main.append(num)
        
        with col2:
            st.subheader("√âtoiles (2)")
            user_stars = []
            cols = st.columns(2)
            for i in range(2):
                with cols[i]:
                    star = st.number_input(f"E{i+1}", min_value=1, max_value=12, value=1+i*5, key=f"user_star_{i}")
                    user_stars.append(star)
        
        if st.button("üîç Valider et Analyser", use_container_width=True, type="primary"):
            with st.spinner("Analyse en cours..."):
                try:
                    # Get probabilities for scoring
                    main_scores, star_scores = _get_cached_probabilities()
                    validation = validate_ticket(user_main, user_stars, main_scores, star_scores)
                    
                    if not validation["valid"]:
                        st.error("‚ùå Ticket invalide")
                        for error in validation["errors"]:
                            st.error(f"‚Ä¢ {error}")
                    else:
                        st.success("‚úÖ Ticket valide!")
                        
                        # Display score
                        col1, col2, col3 = st.columns(3)
                        with col1:
                            st.metric("Score ML", f"{validation['score']:.1f}/100")
                        with col2:
                            st.metric("Probabilit√©", f"{validation['probability']*100:.2f}%")
                        with col3:
                            matches = len(validation["historical_matches"])
                            st.metric("Matches historiques", matches, f"sur 100 tirages")
                        
                        # Warnings
                        if validation["warnings"]:
                            st.warning("‚ö†Ô∏è Avertissements")
                            for warning in validation["warnings"]:
                                st.caption(f"‚Ä¢ {warning}")
                        
                        # Suggestions
                        if validation["suggestions"]:
                            st.info("üí° Suggestions d'am√©lioration")
                            for suggestion in validation["suggestions"]:
                                st.caption(f"‚Ä¢ {suggestion}")
                        
                        # Historical matches
                        if validation["historical_matches"]:
                            with st.expander(f"üìú D√©tail des {len(validation['historical_matches'])} correspondances historiques"):
                                for match in validation["historical_matches"][:10]:
                                    st.caption(f"{match['date']}: {match['main_matches']} num√©ros + {match['star_matches']} √©toiles")
                
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de la validation: {e}")
    
    st.markdown("---")
    
    # Section 4: Generate Tickets
    st.header("üé´ G√©n√©rer des tickets 5+2")
    
    if st.button("üé≤ G√©n√©rer les tickets", use_container_width=True):
        with st.spinner(f"G√©n√©ration de {n_tickets} tickets avec la m√©thode {method}..."):
            try:
                tickets = suggest_tickets_ui(n_tickets, method, seed, use_ensemble, hybrid_weights)
                
                if tickets:
                    st.success(f"‚úÖ {len(tickets)} tickets g√©n√©r√©s avec succ√®s!")
                    
                    # Display tickets
                    st.subheader("üé´ Vos tickets EuroMillions")
                    
                    tickets_text = format_tickets_display(tickets)
                    st.markdown(tickets_text)
                    
                    # Prepare download data
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    
                    # CSV format
                    csv_data = []
                    csv_data.append("Ticket,Boule1,Boule2,Boule3,Boule4,Boule5,Etoile1,Etoile2")
                    for ticket in tickets:
                        balls = ticket['balls']
                        stars = ticket['stars']
                        csv_data.append(f"{ticket['ticket_id']},{balls[0]},{balls[1]},{balls[2]},{balls[3]},{balls[4]},{stars[0]},{stars[1]}")
                    csv_content = '\n'.join(csv_data)
                    
                    # JSON format
                    json_content = json.dumps({
                        "generated_at": datetime.now().isoformat(),
                        "method": method,
                        "seed": seed,
                        "tickets": tickets
                    }, indent=2, ensure_ascii=False)
                    
                    # Download buttons
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.download_button(
                            label="‚¨áÔ∏è CSV",
                            data=csv_content,
                            file_name=f"euromillions_tickets_{timestamp}.csv",
                            mime="text/csv",
                            use_container_width=True
                        )
                    
                    with col2:
                        st.download_button(
                            label="‚¨áÔ∏è JSON",
                            data=json_content,
                            file_name=f"euromillions_tickets_{timestamp}.json",
                            mime="application/json",
                            use_container_width=True
                        )
                    
                    with col3:
                        # TXT format
                        txt_content = f"EuroMillions Tickets\nG√©n√©r√©s le: {datetime.now().strftime('%d/%m/%Y %H:%M')}\n"
                        txt_content += f"M√©thode: {method} | Seed: {seed}\n"
                        txt_content += "=" * 50 + "\n\n"
                        for ticket in tickets:
                            balls = ticket['balls']
                            stars = ticket['stars']
                            txt_content += f"Ticket {ticket['ticket_id']}: {balls[0]}-{balls[1]}-{balls[2]}-{balls[3]}-{balls[4]} + {stars[0]}-{stars[1]}\n"
                        
                        st.download_button(
                            label="‚¨áÔ∏è TXT",
                            data=txt_content,
                            file_name=f"euromillions_tickets_{timestamp}.txt",
                            mime="text/plain",
                            use_container_width=True
                        )
                    
                    with col4:
                        # PDF format
                        pdf_bytes = generate_pdf_tickets(tickets, method, seed)
                        if pdf_bytes:
                            st.download_button(
                                label="‚¨áÔ∏è PDF",
                                data=pdf_bytes,
                                file_name=f"euromillions_tickets_{timestamp}.pdf",
                                mime="application/pdf",
                                use_container_width=True
                            )
                        else:
                            if st.button("üìÑ PDF", disabled=True, use_container_width=True):
                                pass
                            st.caption("Install reportlab")
                    
                    # QR Code option (expandable)
                    with st.expander("üì± QR Codes pour tickets", expanded=False):
                        st.caption("Scannez ces QR codes pour sauvegarder vos tickets")
                        
                        qr_available = False
                        try:
                            import qrcode
                            qr_available = True
                        except ImportError:
                            st.warning("üì¶ Module qrcode non install√©. Installez avec: pip install qrcode[pil]")
                        
                        if qr_available:
                            cols_per_row = 3
                            for i in range(0, min(len(tickets), 9), cols_per_row):  # Show max 9 QR codes
                                cols = st.columns(cols_per_row)
                                for j, col in enumerate(cols):
                                    if i + j < len(tickets):
                                        ticket = tickets[i + j]
                                        with col:
                                            qr_data_url = generate_ticket_qr(ticket)
                                            if qr_data_url:
                                                st.markdown(f"**Ticket {ticket['ticket_id']}**")
                                                st.markdown(f'<img src="{qr_data_url}" width="150"/>', unsafe_allow_html=True)
                            
                            if len(tickets) > 9:
                                st.info(f"Affichage de 9 QR codes sur {len(tickets)} tickets")
                    
                    # Method explanation
                    st.info(f"**M√©thode utilis√©e:** {method} | **Graine:** {seed}")
                    st.caption(METHOD_EXPLANATIONS.get(method, "M√©thode personnalis√©e"))
                    
                    # Number Distribution Visualizer
                    with st.expander("üìä Distribution des num√©ros g√©n√©r√©s", expanded=False):
                        st.subheader("Analyse de couverture")
                        
                        # Count frequency of each number
                        main_freq = Counter()
                        star_freq = Counter()
                        
                        for ticket in tickets:
                            for num in ticket['balls']:
                                main_freq[num] += 1
                            for star in ticket['stars']:
                                star_freq[star] += 1
                        
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            st.caption("üé± Num√©ros principaux")
                            
                            # Create DataFrame for better display
                            main_data = []
                            for num in range(MAIN_NUM_MIN, MAIN_NUM_MAX + 1):
                                count = main_freq.get(num, 0)
                                main_data.append({"Num√©ro": num, "Fr√©quence": count, "Taux %": f"{count/len(tickets)*100:.1f}"})
                            
                            main_df = pd.DataFrame(main_data)
                            
                            # Show most and least used
                            most_used = main_df.nlargest(5, 'Fr√©quence')
                            st.markdown("**Top 5 plus utilis√©s:**")
                            st.dataframe(most_used, hide_index=True, use_container_width=True)
                            
                            least_used = main_df[main_df['Fr√©quence'] == 0]
                            if not least_used.empty:
                                st.markdown(f"**Non utilis√©s:** {len(least_used)} num√©ros")
                                st.caption(", ".join(str(n) for n in least_used['Num√©ro'].tolist()))
                            else:
                                st.success("‚úÖ Couverture compl√®te!")
                        
                        with col2:
                            st.caption("‚≠ê √âtoiles")
                            
                            star_data = []
                            for star in range(STAR_NUM_MIN, STAR_NUM_MAX + 1):
                                count = star_freq.get(star, 0)
                                star_data.append({"√âtoile": star, "Fr√©quence": count, "Taux %": f"{count/len(tickets)*100:.1f}"})
                            
                            star_df = pd.DataFrame(star_data)
                            st.dataframe(star_df, hide_index=True, use_container_width=True)
                            
                            unused_stars = star_df[star_df['Fr√©quence'] == 0]
                            if not unused_stars.empty:
                                st.info(f"Non utilis√©es: {', '.join(str(s) for s in unused_stars['√âtoile'].tolist())}")
                        
                        # Coverage metrics
                        total_main_coverage = (len(main_freq) / MAIN_NUM_MAX) * 100
                        total_star_coverage = (len(star_freq) / STAR_NUM_MAX) * 100
                        
                        col1, col2 = st.columns(2)
                        with col1:
                            st.metric("Couverture num√©ros", f"{total_main_coverage:.1f}%", f"{len(main_freq)}/{MAIN_NUM_MAX}")
                        with col2:
                            st.metric("Couverture √©toiles", f"{total_star_coverage:.1f}%", f"{len(star_freq)}/{STAR_NUM_MAX}")
                    
                    # Save configuration preset
                    st.markdown("---")
                    st.subheader("üíæ Sauvegarder cette configuration")
                    col1, col2 = st.columns([3, 1])
                    with col1:
                        preset_name = st.text_input(
                            "Nom du pr√©r√©glage",
                            value=f"{method}_seed{seed}",
                            key="preset_name_input"
                        )
                    with col2:
                        st.write("")
                        st.write("")
                        if st.button("üíæ Sauvegarder", use_container_width=True):
                            config = {
                                "n_tickets": n_tickets,
                                "method": method,
                                "seed": seed,
                                "use_ensemble": use_ensemble
                            }
                            if save_config_preset(preset_name, config):
                                st.success(f"‚úÖ Configuration '{preset_name}' sauvegard√©e!")
                    
                    # Save for performance tracking
                    tracking_data = {
                        "method": method,
                        "seed": seed,
                        "n_tickets": n_tickets,
                        "tickets": tickets[:10]  # Keep first 10 for tracking
                    }
                    save_performance_tracking(tracking_data)
                
                else:
                    st.warning("‚ö†Ô∏è Aucun ticket g√©n√©r√©. V√©rifiez que les mod√®les sont entra√Æn√©s.")
                    
            except Exception as e:
                st.error(f"‚ùå Erreur lors de la g√©n√©ration: {e}")
    
    st.markdown("---")
    
    # Section 4.5: Performance Tracking
    st.header("üìà Suivi de Performance")
    
    if st.button("üîÑ Actualiser les statistiques", use_container_width=True):
        with st.spinner("Analyse des performances..."):
            try:
                perf_data = check_predictions_vs_draws()
                
                if perf_data["total_predictions"] == 0:
                    st.info("‚ÑπÔ∏è Aucune pr√©diction √† analyser. G√©n√©rez des tickets pour commencer le suivi.")
                else:
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric("Pr√©dictions", perf_data["total_predictions"])
                    with col2:
                        st.metric("V√©rifi√©es", perf_data["checked"])
                    with col3:
                        st.metric("Meilleur match", f"{perf_data['best_match']['main']}+{perf_data['best_match']['stars']}")
                    with col4:
                        win_count = len(perf_data["wins"])
                        st.metric("Gains (2+)", win_count)
                    
                    if perf_data["wins"]:
                        st.subheader("üèÜ Historique des gains")
                        wins_df = pd.DataFrame(perf_data["wins"])
                        display_wins = wins_df[['date', 'main_matches', 'star_matches']].copy()
                        display_wins.columns = ['Date', 'Num√©ros', '√âtoiles']
                        st.dataframe(display_wins, use_container_width=True, hide_index=True)
                    
                    # Performance insights
                    if perf_data["checked"] > 0:
                        avg_main = perf_data["total_matches"]["main"] / perf_data["checked"]
                        avg_stars = perf_data["total_matches"]["stars"] / perf_data["checked"]
                        
                        st.info(f"üìä Moyenne par ticket: {avg_main:.2f} num√©ros corrects, {avg_stars:.2f} √©toiles correctes")
            
            except Exception as e:
                st.error(f"‚ùå Erreur lors de l'analyse: {e}")
    
    st.markdown("---")
    
    # Section 5: Manual Draw Entry
    st.header("‚ûï Ajouter un tirage manuellement")
    
    with st.expander("üìù Saisir un nouveau tirage", expanded=False):
        st.subheader("Informations du tirage")
        
        # Date input
        draw_date = st.date_input(
            "Date du tirage",
            value=datetime.now().date(),
            help="Date du tirage officiel"
        )
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("üé± Num√©ros principaux (1-50)")
            main_numbers = []
            
            # 5 number inputs for main numbers
            for i in range(5):
                num = st.number_input(
                    f"Num√©ro {i+1}",
                    min_value=1,
                    max_value=50,
                    value=1,
                    key=f"main_{i}",
                    help=f"Num√©ro principal {i+1} (entre 1 et 50)"
                )
                main_numbers.append(num)
        
        with col2:
            st.subheader("‚≠ê √âtoiles (1-12)")
            stars = []
            
            # 2 star inputs
            for i in range(2):
                star = st.number_input(
                    f"√âtoile {i+1}",
                    min_value=1,
                    max_value=12,
                    value=1,
                    key=f"star_{i}",
                    help=f"√âtoile {i+1} (entre 1 et 12)"
                )
                stars.append(star)
        
        # Validation and preview
        col1, col2 = st.columns(2)
        
        with col1:
            # Validate inputs
            main_numbers_sorted = sorted(main_numbers)
            stars_sorted = sorted(stars)
            
            # Check for duplicates in main numbers
            main_duplicates = len(main_numbers) != len(set(main_numbers))
            # Check for duplicates in stars
            star_duplicates = len(stars) != len(set(stars))
            
            if main_duplicates:
                st.error("‚ùå Les num√©ros principaux doivent √™tre diff√©rents")
            elif star_duplicates:
                st.error("‚ùå Les √©toiles doivent √™tre diff√©rentes")
            else:
                st.success("‚úÖ Tirage valide")
                
                # Preview
                st.info(f"**Aper√ßu:** {' - '.join(map(str, main_numbers_sorted))} | ‚≠ê {' - '.join(map(str, stars_sorted))}")
        
        with col2:
            # Add button
            if st.button("üíæ Ajouter le tirage", disabled=main_duplicates or star_duplicates):
                with st.spinner("Ajout du tirage en cours..."):
                    try:
                        # Import here to avoid circular imports
                        from repository import EuromillionsRepository
                        
                        # Create draw ID
                        draw_id = f"EM-{draw_date.strftime('%Y-%m-%d')}"
                        
                        # Prepare draw data
                        draw_data = {
                            'draw_id': draw_id,
                            'draw_date': draw_date.strftime('%Y-%m-%d'),
                            'n1': main_numbers_sorted[0],
                            'n2': main_numbers_sorted[1],
                            'n3': main_numbers_sorted[2],
                            'n4': main_numbers_sorted[3],
                            'n5': main_numbers_sorted[4],
                            's1': stars_sorted[0],
                            's2': stars_sorted[1],
                            'jackpot': None,
                            'prize_table': None,
                            'raw_html': None
                        }
                        
                        # Save to database
                        repo = EuromillionsRepository()
                        result = repo.upsert_draws([draw_data])
                        
                        if result['inserted'] > 0:
                            st.success(f"‚úÖ Tirage ajout√© avec succ√®s ! (ID: {draw_id})")
                            st.info("üí° Pensez √† re-entra√Æner les mod√®les pour inclure ce nouveau tirage")
                        elif result['updated'] > 0:
                            st.warning(f"‚ö†Ô∏è Tirage existant mis √† jour (ID: {draw_id})")
                        else:
                            st.error("‚ùå √âchec de l'ajout du tirage")
                            
                    except Exception as e:
                        st.error(f"‚ùå Erreur lors de l'ajout: {e}")
    
    st.markdown("---")
    
    # Section 6: CSV Import
    st.header("üìÑ Import CSV")
    
    with st.expander("üìÇ Importer des tirages depuis un fichier CSV", expanded=False):
        st.subheader("T√©l√©chargement de fichier CSV")
        
        uploaded_file = st.file_uploader(
            "Choisissez un fichier CSV FDJ",
            type=['csv'],
            help="Fichier CSV au format FDJ avec les tirages EuroMillions"
        )
        
        if uploaded_file is not None:
            # Preview file content
            try:
                # Read content once
                import io
                uploaded_file.seek(0)
                content = uploaded_file.read()
                
                # Try different encodings
                encodings = ['utf-8', 'latin1', 'cp1252']
                df_preview = None
                used_encoding = None
                decoded_content = None
                
                for encoding in encodings:
                    try:
                        decoded_content = content.decode(encoding)
                        df_preview = pd.read_csv(io.StringIO(decoded_content), nrows=5)
                        used_encoding = encoding
                        break
                    except (UnicodeDecodeError, pd.errors.ParserError):
                        continue
                
                if df_preview is not None and decoded_content is not None:
                    st.subheader("Aper√ßu du fichier")
                    st.dataframe(df_preview, use_container_width=True)
                    
                    # Use already decoded content
                    line_count = len(decoded_content.split('\n'))
                    st.caption(f"Encodage d√©tect√©: {used_encoding} | Lignes totales: {line_count}")
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        if st.button("üîç Analyser le fichier complet"):
                            with st.spinner("Analyse du fichier..."):
                                try:
                                    uploaded_file.seek(0)
                                    df_full = pd.read_csv(io.StringIO(content.decode(used_encoding)))
                                    
                                    st.subheader("Statistiques du fichier")
                                    st.metric("Nombre de lignes", len(df_full))
                                    st.metric("Nombre de colonnes", len(df_full.columns))
                                    
                                    # Show column names
                                    st.subheader("Colonnes d√©tect√©es")
                                    st.write(list(df_full.columns))
                                    
                                except Exception as e:
                                    st.error(f"Erreur lors de l'analyse: {e}")
                    
                    with col2:
                        if st.button("üì• Importer les donn√©es"):
                            with st.spinner("Import des donn√©es en cours..."):
                                try:
                                    # Save temporarily and import
                                    import tempfile
                                    import os
                                    
                                    # Create temporary file
                                    with tempfile.NamedTemporaryFile(mode='wb', suffix='.csv', delete=False) as tmp_file:
                                        uploaded_file.seek(0)
                                        tmp_file.write(uploaded_file.read())
                                        temp_path = tmp_file.name
                                    
                                    # Import using existing function
                                    import subprocess
                                    import sys
                                    
                                    # Run import script
                                    result = subprocess.run([
                                        sys.executable, 'import_fdj_special.py', temp_path
                                    ], capture_output=True, text=True, cwd=os.getcwd())
                                    
                                    # Clean up
                                    os.unlink(temp_path)
                                    
                                    if result.returncode == 0:
                                        st.success("‚úÖ Import r√©ussi !")
                                        st.text("Sortie:")
                                        st.code(result.stdout)
                                        st.info("üí° Pensez √† re-entra√Æner les mod√®les avec les nouvelles donn√©es")
                                    else:
                                        st.error("‚ùå √âchec de l'import")
                                        st.text("Erreur:")
                                        st.code(result.stderr)
                                        
                                except Exception as e:
                                    st.error(f"‚ùå Erreur lors de l'import: {e}")
                else:
                    st.error("‚ùå Impossible de lire le fichier. V√©rifiez le format CSV.")
                    
            except Exception as e:
                st.error(f"‚ùå Erreur lors de la lecture du fichier: {e}")
    
    st.markdown("---")
    
    # Section 7: History
    st.header("üóÇÔ∏è Historique")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üìú Voir les 20 derniers tirages", use_container_width=True):
            with st.spinner("Chargement de l'historique..."):
                try:
                    recent_draws = fetch_last_draws(20)
                    
                    if not recent_draws.empty:
                        st.subheader("üìã Derniers tirages")
                        
                        # Format for display
                        display_df = recent_draws[['draw_date', 'balls', 'stars']].rename(columns={
                            'draw_date': 'Date',
                            'balls': 'Boules principales',
                            'stars': '√âtoiles'
                        })
                        
                        st.dataframe(
                            display_df,
                            use_container_width=True,
                            hide_index=True
                        )
                    else:
                        st.warning("‚ö†Ô∏è Aucun tirage trouv√© dans l'historique.")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors du chargement: {e}")
    
    with col2:
        if st.button("‚¨áÔ∏è Exporter l'historique (CSV)", use_container_width=True):
            with st.spinner("Pr√©paration de l'export..."):
                try:
                    filename, csv_bytes = export_all_draws_csv()
                    
                    if csv_bytes:
                        st.download_button(
                            label="üìÅ T√©l√©charger l'historique complet",
                            data=csv_bytes,
                            file_name=filename,
                            mime="text/csv",
                            use_container_width=True
                        )
                        
                        file_size = len(csv_bytes)
                        st.success(f"‚úÖ Export pr√™t: {filename} ({file_size:,} octets)")
                    else:
                        st.warning("‚ö†Ô∏è Aucune donn√©e √† exporter.")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de l'export: {e}")
    
    # Footer with system status
    st.markdown("---")
    
    with st.expander("‚ÑπÔ∏è √âtat du syst√®me"):
        try:
            status = get_system_status()
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("üìä Donn√©es")
                if status.get("data", {}).get("available", False):
                    data_info = status["data"]
                    st.success(f"‚úÖ {data_info['count']} tirages disponibles")
                    if data_info.get("first_date") and data_info.get("last_date"):
                        st.caption(f"Du {data_info['first_date']} au {data_info['last_date']}")
                else:
                    st.error("‚ùå Aucune donn√©e disponible")
            
            with col2:
                st.subheader("ü§ñ Mod√®les")
                if status.get("models", {}).get("available", False):
                    model_info = status["models"]
                    st.success("‚úÖ Mod√®les disponibles")
                    if model_info.get("trained_at"):
                        st.caption(f"Entra√Æn√©s le: {model_info['trained_at']}")
                else:
                    st.error("‚ùå Aucun mod√®le entra√Æn√©")
            
            # Recommendations
            recommendations = status.get("recommendations", [])
            if recommendations:
                st.subheader("üí° Recommandations")
                for rec in recommendations:
                    st.info(f"‚Ä¢ {rec}")
            
            # Smart Alerts
            st.subheader("üîî Alertes Intelligentes")
            
            from repository import get_repository
            repo = get_repository()
            draws = repo.all_draws_df()
            
            if not draws.empty:
                last_draw_date = datetime.fromisoformat(draws.iloc[-1]['draw_date'])
                days_since = (datetime.now() - last_draw_date).days
                
                if days_since > 7:
                    st.warning(f"‚ö†Ô∏è Derni√®re mise √† jour il y a {days_since} jours - Rafra√Æchissement recommand√©")
                else:
                    st.success(f"‚úÖ Donn√©es √† jour ({days_since} jours)")
            
            if status.get("models", {}).get("available"):
                model_date = status["models"].get("trained_at", "")
                if model_date:
                    trained_at = datetime.fromisoformat(model_date.split("T")[0])
                    days_old = (datetime.now() - trained_at).days
                    if days_old > 30:
                        st.warning(f"‚ö†Ô∏è Mod√®les entra√Æn√©s il y a {days_old} jours - R√©entra√Ænement recommand√©")
                    
        except Exception as e:
            st.error(f"‚ùå Erreur lors de la r√©cup√©ration du statut: {e}")


if __name__ == "__main__":
    main()
