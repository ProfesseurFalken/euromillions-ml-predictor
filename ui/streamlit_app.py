#!/usr/bin/env python3
"""
EuroMillions Streamlit UI
========================

Single-page graphical interface for EuroMillions ML prediction system.
Provides data management, model training, prediction generation, and export functionality.
"""

import os
import json
import streamlit as st
import pandas as pd
from datetime import datetime
from pathlib import Path
import sys

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from streamlit_adapters import (
    init_full_history,
    update_incremental,
    train_from_scratch,
    train_ensemble_models,
    reload_models,
    get_scores,
    suggest_tickets_ui,
    fetch_last_draws,
    export_all_draws_csv,
    get_system_status
)

# Import backtesting functionality
import numpy as np
from typing import Dict, List, Any

# Page configuration
st.set_page_config(
    page_title="EuroMillions ‚Äî Console Graphique", 
    page_icon="üé≤", 
    layout="centered"
)

def load_env_settings():
    """Load current .env settings."""
    env_file = Path(".env")
    settings = {
        "STORAGE_DIR": "./data",
        "DB_URL": "sqlite:///./data/draws.db", 
        "USER_AGENT": "EuromillionsPro/1.0 (+contact)",
        "REQUEST_TIMEOUT": "15",
        "MAX_RETRIES": "3"
    }
    
    if env_file.exists():
        with open(env_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip().strip('"\'')
                    if key in settings:
                        settings[key] = value
    
    return settings

def save_env_settings(settings):
    """Save settings to .env file."""
    env_content = []
    env_content.append("# EuroMillions Configuration")
    env_content.append("# Generated by Streamlit UI")
    env_content.append(f"# Updated: {datetime.now().isoformat()}")
    env_content.append("")
    
    for key, value in settings.items():
        env_content.append(f'{key}="{value}"')
    
    env_content.append("")
    
    with open(".env", 'w', encoding='utf-8') as f:
        f.write('\n'.join(env_content))

def format_tickets_display(tickets):
    """Format enhanced tickets for display with confidence scores."""
    if not tickets:
        return "Aucun ticket g√©n√©r√©"
    
    display_lines = []
    for ticket in tickets:
        balls_str = ticket['balls_str']
        stars_str = ticket['stars_str']
        
        # Get confidence info
        confidence = ticket.get('confidence', 50.0)
        confidence_level = ticket.get('confidence_level', 'Moyenne')
        method = ticket.get('method', 'unknown')
        
        # Choose confidence emoji
        if confidence >= 80:
            confidence_emoji = "üî•"
        elif confidence >= 65:
            confidence_emoji = "‚ö°"
        elif confidence >= 50:
            confidence_emoji = "‚ú®"
        else:
            confidence_emoji = "üí´"
        
        # Format with confidence and method info
        ticket_display = f"""üé´ **Ticket {ticket['ticket_id']}** {confidence_emoji}

   {balls_str}
   ‚≠ê {stars_str}
   
   üìä **Confiance:** {confidence}% ({confidence_level})
   üéØ **M√©thode:** {method}"""
        
        display_lines.append(ticket_display)
    
    return '\n\n---\n\n'.join(display_lines)


def _generate_tickets_fast(n: int, method: str, seed: int, main_scores: dict, star_scores: dict) -> List[dict]:
    """
    G√©n√®re des tickets RAPIDEMENT en utilisant des probabilit√©s pr√©calcul√©es.
    √âvite le rechargement des mod√®les ML √† chaque appel.
    
    Args:
        n: Nombre de tickets
        method: M√©thode de g√©n√©ration
        seed: Graine al√©atoire
        main_scores: Probabilit√©s pr√©calcul√©es pour les num√©ros principaux {1:0.12, 2:0.08, ...}
        star_scores: Probabilit√©s pr√©calcul√©es pour les √©toiles {1:0.15, 2:0.09, ...}
    
    Returns:
        Liste de tickets {main: [1,2,3,4,5], stars: [1,2]}
    """
    import numpy as np
    
    np.random.seed(seed)
    tickets = []
    
    # Convertir dictionnaires en listes tri√©es - FIXED: extraire seulement les probabilit√©s
    main_nums = list(range(1, 51))
    star_nums = list(range(1, 13))
    # main_scores et star_scores contiennent des tuples (num, prob) - extraire seulement prob
    main_probs = np.array([main_scores[i][1] if isinstance(main_scores[i], tuple) else main_scores[i] for i in main_nums])
    star_probs = np.array([star_scores[i][1] if isinstance(star_scores[i], tuple) else star_scores[i] for i in star_nums])
    
    for i in range(n):
        if method == "topk":
            # Top-K d√©terministe - FIXED v4
            top_main_idx = np.argsort(main_probs)[-5:]
            top_star_idx = np.argsort(star_probs)[-2:]
            # Op√©ration vectorielle numpy puis conversion en liste
            main = sorted((top_main_idx + 1).tolist())
            stars = sorted((top_star_idx + 1).tolist())
        
        elif method == "random":
            # Al√©atoire pond√©r√© par probabilit√©s
            main_probs_norm = main_probs / main_probs.sum()
            star_probs_norm = star_probs / star_probs.sum()
            main = sorted(np.random.choice(main_nums, size=5, replace=False, p=main_probs_norm).tolist())
            stars = sorted(np.random.choice(star_nums, size=2, replace=False, p=star_probs_norm).tolist())
        
        elif method == "hybrid":
            # Hybride : 60% topk + 40% random - FIXED v4
            top_main_idx = np.argsort(main_probs)[-10:]  # Top 10 num√©ros (numpy array)
            top_star_idx = np.argsort(star_probs)[-5:]   # Top 5 √©toiles (numpy array)
            
            # Extraire les probabilit√©s correspondantes (encore numpy)
            top_main_probs = main_probs[top_main_idx]
            top_star_probs = star_probs[top_star_idx]
            
            # Normaliser les probabilit√©s
            top_main_probs_norm = (top_main_probs / top_main_probs.sum()).flatten()
            top_star_probs_norm = (top_star_probs / top_star_probs.sum()).flatten()
            
            # Convertir indices en num√©ros pour np.random.choice (force 1D)
            top_main_nums = (top_main_idx + 1).flatten()
            top_star_nums = (top_star_idx + 1).flatten()
            
            main = sorted(np.random.choice(top_main_nums, size=5, replace=False, p=top_main_probs_norm).tolist())
            stars = sorted(np.random.choice(top_star_nums, size=2, replace=False, p=top_star_probs_norm).tolist())
        
        elif method in ["ensemble", "advanced_hybrid"]:
            # Pour ensemble/advanced_hybrid - FIXED v4
            top_main_idx = np.argsort(main_probs)[-10:]
            top_star_idx = np.argsort(star_probs)[-5:]
            
            top_main_probs = main_probs[top_main_idx]
            top_star_probs = star_probs[top_star_idx]
            top_main_probs_norm = (top_main_probs / top_main_probs.sum()).flatten()
            top_star_probs_norm = (top_star_probs / top_star_probs.sum()).flatten()
            
            # Convertir indices en num√©ros (force 1D)
            top_main_nums = (top_main_idx + 1).flatten()
            top_star_nums = (top_star_idx + 1).flatten()
            
            main = sorted(np.random.choice(top_main_nums, size=5, replace=False, p=top_main_probs_norm).tolist())
            stars = sorted(np.random.choice(top_star_nums, size=2, replace=False, p=top_star_probs_norm).tolist())
        
        else:
            # Fallback : random simple
            main = sorted(np.random.choice(main_nums, size=5, replace=False).tolist())
            stars = sorted(np.random.choice(star_nums, size=2, replace=False).tolist())
        
        tickets.append({
            'main': main,
            'stars': stars
        })
        
        # Variation de la graine pour chaque ticket
        np.random.seed(seed + i + 1)
    
    return tickets


def run_backtesting(seeds: List[int], methods: List[str], n_draws: int, n_tickets: int) -> pd.DataFrame:
    """
    Lance le backtesting OPTIMIS√â pour trouver les meilleures configurations.
    Pr√©calcule les probabilit√©s ML UNE SEULE FOIS au d√©but pour acc√©l√©rer drastiquement.
    
    Args:
        seeds: Liste des graines √† tester
        methods: Liste des m√©thodes √† tester
        n_draws: Nombre de tirages r√©cents √† utiliser
        n_tickets: Nombre de tickets par tirage
        
    Returns:
        DataFrame avec les r√©sultats
    """
    from repository import get_repository
    import train_models
    import time
    
    repo = get_repository()
    all_draws = repo.all_draws_df()
    test_draws = all_draws.tail(n_draws)
    
    # ====== PR√âPARATION DES DONN√âES ======
    # Convertir les colonnes n1-n5, s1-s2 en listes 'main' et 'stars'
    test_draws = test_draws.copy()
    test_draws['main'] = test_draws.apply(lambda row: [row['n1'], row['n2'], row['n3'], row['n4'], row['n5']], axis=1)
    test_draws['stars'] = test_draws.apply(lambda row: [row['s1'], row['s2']], axis=1)
    
    # V√©rification des donn√©es
    if len(test_draws) == 0:
        st.error("‚ùå Aucun tirage trouv√© dans la base de donn√©es !")
        return pd.DataFrame()
    
    st.info(f"üìä {len(test_draws)} tirages historiques charg√©s pour le backtesting")
    
    # Afficher un exemple de tirage pour v√©rification
    first_draw = test_draws.iloc[0]
    st.text(f"Exemple: {first_draw['main']} + {first_draw['stars']}")
    
    # ====== OPTIMISATION MAJEURE ======
    # Pr√©calculer les probabilit√©s ML UNE SEULE FOIS (au lieu de les recalculer des milliers de fois)
    status_precalc = st.empty()
    status_precalc.text("‚ö° Optimisation : Pr√©calcul des probabilit√©s ML (une seule fois)...")
    
    try:
        # Charger les mod√®les une fois en cache
        main_proba = train_models.score_balls()
        star_proba = train_models.score_stars()
        
        # Cr√©er un dictionnaire de probabilit√©s pr√©calcul√©es
        main_scores = {i: main_proba[i-1] for i in range(1, 51)}
        star_scores = {i: star_proba[i-1] for i in range(1, 13)}
        
        status_precalc.text("‚úÖ Probabilit√©s ML pr√©calcul√©es et mises en cache")
        time.sleep(0.5)
        status_precalc.empty()
    except Exception as e:
        status_precalc.text(f"‚ö†Ô∏è Impossible de pr√©calculer les probas, fallback au mode classique")
        main_scores = None
        star_scores = None
    
    results = []
    total_tests = len(seeds) * len(methods)
    progress_bar = st.progress(0)
    status_text = st.empty()
    current_test = 0
    
    for seed in seeds:
        for method in methods:
            current_test += 1
            progress_bar.progress(current_test / total_tests)
            status_text.text(f"‚ö° Test {current_test}/{total_tests}: seed={seed}, method={method}")
            
            total_main_matches = 0
            total_star_matches = 0
            total_score = 0
            best_result = {'main': 0, 'stars': 0}
            jackpot_count = 0
            rank2_count = 0
            rank3_count = 0
            any_win_count = 0
            
            for idx, actual_draw in test_draws.iterrows():
                try:
                    # ====== G√âN√âRATION OPTIMIS√âE ======
                    # Utiliser les probabilit√©s pr√©calcul√©es au lieu de recharger les mod√®les
                    if main_scores and star_scores:
                        tickets = _generate_tickets_fast(n_tickets, method, seed, main_scores, star_scores)
                    else:
                        # Fallback si pr√©calcul impossible
                        tickets = suggest_tickets_ui(
                            n=n_tickets,
                            method=method,
                            seed=seed,
                            use_ensemble=(method == "ensemble")
                        )
                    
                    # CORRECTIF: Extraire les num√©ros du DataFrame (colonnes n1-n5, s1-s2)
                    actual_main = [actual_draw['n1'], actual_draw['n2'], actual_draw['n3'], 
                                   actual_draw['n4'], actual_draw['n5']]
                    actual_stars = [actual_draw['s1'], actual_draw['s2']]
                    
                    # √âvaluer chaque ticket
                    for ticket in tickets:
                        main_matches = len(set(ticket['main']) & set(actual_main))
                        star_matches = len(set(ticket['stars']) & set(actual_stars))
                        
                        total_main_matches += main_matches
                        total_star_matches += star_matches
                        score = main_matches * 10 + star_matches * 5
                        total_score += score
                        
                        # Meilleur r√©sultat
                        if (main_matches > best_result['main'] or 
                            (main_matches == best_result['main'] and star_matches > best_result['stars'])):
                            best_result = {'main': main_matches, 'stars': star_matches}
                        
                        # Compter les gains
                        if main_matches == 5 and star_matches == 2:
                            jackpot_count += 1
                        elif main_matches == 5 and star_matches == 1:
                            rank2_count += 1
                        elif main_matches == 5 and star_matches == 0:
                            rank3_count += 1
                        
                        if main_matches >= 2 or star_matches >= 1:
                            any_win_count += 1
                            
                except Exception as e:
                    # AM√âLIORATION: Logger les erreurs au lieu de les ignorer silencieusement
                    import traceback
                    error_msg = f"‚ùå Erreur seed={seed}, method={method}, draw={idx}: {str(e)}"
                    st.warning(error_msg)
                    print(f"\n{error_msg}")
                    print(traceback.format_exc())
                    continue
            
            n_total_tickets = n_draws * n_tickets
            
            results.append({
                'seed': seed,
                'method': method,
                'avg_score': total_score / n_total_tickets if n_total_tickets > 0 else 0,
                'avg_main': total_main_matches / n_total_tickets if n_total_tickets > 0 else 0,
                'avg_stars': total_star_matches / n_total_tickets if n_total_tickets > 0 else 0,
                'best_main': best_result['main'],
                'best_stars': best_result['stars'],
                'jackpots': jackpot_count,
                'rank2': rank2_count,
                'rank3': rank3_count,
                'any_win': any_win_count,
                'win_rate': (any_win_count / n_total_tickets * 100) if n_total_tickets > 0 else 0
            })
    
    progress_bar.empty()
    status_text.empty()
    
    df_results = pd.DataFrame(results)
    df_results = df_results.sort_values('avg_score', ascending=False)
    
    return df_results


def main():
    """Main Streamlit application."""
    
    # Title and header
    st.title("üé≤ EuroMillions ‚Äî Console Graphique")
    st.markdown("Interface de gestion compl√®te pour le syst√®me de pr√©diction EuroMillions")
    
    # Sidebar configuration
    with st.sidebar:
        st.header("üéØ Suggestions")
        
        # Suggestion parameters
        n_tickets = st.slider(
            "Nombre de tickets",
            min_value=1,
            max_value=20,
            value=10,
            help="Nombre de combinaisons √† g√©n√©rer"
        )
        
        method = st.selectbox(
            "M√©thode de g√©n√©ration",
            options=["hybrid", "ensemble", "advanced_hybrid", "topk", "random"],
            index=0,
            help="Strat√©gie de s√©lection des num√©ros"
        )
        
        # Advanced options
        st.subheader("üîß Options avanc√©es")
        
        use_ensemble = st.checkbox(
            "Utiliser les mod√®les d'ensemble",
            value=True,
            help="Combine plusieurs algorithmes ML pour de meilleures pr√©dictions"
        )
        
        # Hybrid strategy weights (only for advanced_hybrid)
        if method == "advanced_hybrid":
            st.subheader("‚öñÔ∏è Poids de la strat√©gie hybride")
            
            col1, col2 = st.columns(2)
            with col1:
                ml_weight = st.slider("ML", 0.0, 1.0, 0.4, 0.1, help="Poids des pr√©dictions ML")
                freq_weight = st.slider("Fr√©quence", 0.0, 1.0, 0.3, 0.1, help="Poids de l'analyse de fr√©quence")
            
            with col2:
                pattern_weight = st.slider("Motifs", 0.0, 1.0, 0.2, 0.1, help="Poids de l'analyse des motifs")
                gap_weight = st.slider("√âcarts", 0.0, 1.0, 0.1, 0.1, help="Poids de l'analyse des √©carts")
            
            # Normalize weights
            total_weight = ml_weight + freq_weight + pattern_weight + gap_weight
            if total_weight > 0:
                hybrid_weights = {
                    "ml_weight": ml_weight / total_weight,
                    "freq_weight": freq_weight / total_weight,
                    "pattern_weight": pattern_weight / total_weight,
                    "gap_weight": gap_weight / total_weight
                }
            else:
                hybrid_weights = None
        else:
            hybrid_weights = None
        
        seed = st.number_input(
            "Graine al√©atoire",
            min_value=1,
            max_value=9999,
            value=42,
            help="Pour reproductibilit√© des r√©sultats"
        )
        
        st.markdown("---")
        
        # Settings expander
        with st.expander("‚öôÔ∏è Param√®tres (.env)"):
            st.subheader("Configuration syst√®me")
            
            # Load current settings
            current_settings = load_env_settings()
            
            # Settings form
            with st.form("env_settings"):
                new_settings = {}
                
                new_settings["STORAGE_DIR"] = st.text_input(
                    "R√©pertoire de stockage",
                    value=current_settings["STORAGE_DIR"],
                    help="Dossier pour les donn√©es"
                )
                
                new_settings["DB_URL"] = st.text_input(
                    "URL de base de donn√©es",
                    value=current_settings["DB_URL"],
                    help="Chemin vers la base SQLite"
                )
                
                new_settings["USER_AGENT"] = st.text_input(
                    "User Agent",
                    value=current_settings["USER_AGENT"],
                    help="Identification pour les requ√™tes web"
                )
                
                new_settings["REQUEST_TIMEOUT"] = st.text_input(
                    "Timeout requ√™tes (sec)",
                    value=current_settings["REQUEST_TIMEOUT"],
                    help="D√©lai d'attente des requ√™tes"
                )
                
                new_settings["MAX_RETRIES"] = st.text_input(
                    "Nombre de tentatives",
                    value=current_settings["MAX_RETRIES"],
                    help="Retries en cas d'√©chec"
                )
                
                if st.form_submit_button("üíæ Enregistrer param√®tres"):
                    try:
                        save_env_settings(new_settings)
                        st.success("‚úÖ Param√®tres sauvegard√©s dans .env")
                        st.rerun()
                    except Exception as e:
                        st.error(f"‚ùå Erreur lors de la sauvegarde: {e}")
    
    # Main content sections
    
    # Section 1: Initialization & Updates
    st.header("üîß Initialisation & Mise √† jour")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üì• T√©l√©charger l'historique & Initialiser", use_container_width=True):
            with st.spinner("T√©l√©chargement de l'historique complet..."):
                try:
                    result = init_full_history()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        st.json(result)
                    else:
                        st.error(f"‚ùå {result['message']}")
                        st.json(result)
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de l'initialisation: {e}")
    
    with col2:
        if st.button("üîÑ Mettre √† jour (derniers tirages)", use_container_width=True):
            with st.spinner("Mise √† jour des derniers tirages..."):
                try:
                    result = update_incremental()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        st.json(result)
                    else:
                        st.error(f"‚ùå {result['message']}")
                        st.json(result)
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de la mise √† jour: {e}")
    
    st.markdown("---")
    
    # Section 2: Training
    st.header("üß† Entra√Ænement")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üèãÔ∏è Entra√Æner (from scratch)", use_container_width=True):
            with st.spinner("Entra√Ænement des mod√®les en cours..."):
                try:
                    result = train_from_scratch()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        
                        # Display training metrics
                        metrics_col1, metrics_col2 = st.columns(2)
                        with metrics_col1:
                            if result.get("main_logloss"):
                                st.metric("Log-loss boules principales", f"{result['main_logloss']:.4f}")
                        with metrics_col2:
                            if result.get("star_logloss"):
                                st.metric("Log-loss √©toiles", f"{result['star_logloss']:.4f}")
                        
                        if result.get("training_data_size"):
                            st.info(f"üìä Donn√©es d'entra√Ænement: {result['training_data_size']} tirages")
                    else:
                        st.error(f"‚ùå {result['message']}")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de l'entra√Ænement: {e}")
    
    with col2:
        if st.button("ü§ñ Ensemble de mod√®les", use_container_width=True):
            with st.spinner("Entra√Ænement des mod√®les d'ensemble..."):
                try:
                    result = train_ensemble_models()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        
                        if result.get("models_trained"):
                            st.info(f"üéØ Mod√®les entra√Æn√©s: {', '.join(result['models_trained'])}")
                        
                        if result.get("performance"):
                            perf = result["performance"]
                            metrics_col1, metrics_col2 = st.columns(2)
                            with metrics_col1:
                                if "ensemble_score" in perf:
                                    st.metric("Score d'ensemble", f"{perf['ensemble_score']:.4f}")
                            with metrics_col2:
                                if "best_model" in perf:
                                    st.metric("Meilleur mod√®le", perf["best_model"])
                    else:
                        st.warning(f"‚ö†Ô∏è {result['message']}")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de l'entra√Ænement d'ensemble: {e}")
    
    with col3:
        if st.button("üì¶ Recharger le mod√®le", use_container_width=True):
            with st.spinner("Rechargement du mod√®le..."):
                try:
                    result = reload_models()
                    
                    if result.get("success", False):
                        st.success(f"‚úÖ {result['message']}")
                        
                        if result.get("trained_at"):
                            st.info(f"üìÖ Entra√Æn√© le: {result['trained_at']}")
                    else:
                        st.error(f"‚ùå {result['message']}")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors du rechargement: {e}")
    
    st.markdown("---")
    
    # Section 3: Current Probabilities
    st.header("üìä Probabilit√©s actuelles")
    
    if st.button("üîÑ Actualiser les probabilit√©s"):
        with st.spinner("Calcul des probabilit√©s..."):
            try:
                balls_df, stars_df = get_scores()
                
                if not balls_df.empty and not stars_df.empty:
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.subheader("üé± Top 15 boules principales")
                        top_balls = balls_df.head(15)
                        st.dataframe(
                            top_balls[['ball', 'percentage', 'rank']].rename(columns={
                                'ball': 'Boule',
                                'percentage': 'Probabilit√© (%)',
                                'rank': 'Rang'
                            }),
                            use_container_width=True,
                            hide_index=True
                        )
                    
                    with col2:
                        st.subheader("‚≠ê Top 5 √©toiles")
                        top_stars = stars_df.head(5)
                        st.dataframe(
                            top_stars[['star', 'percentage', 'rank']].rename(columns={
                                'star': '√âtoile',
                                'percentage': 'Probabilit√© (%)',
                                'rank': 'Rang'
                            }),
                            use_container_width=True,
                            hide_index=True
                        )
                else:
                    st.warning("‚ö†Ô∏è Aucune probabilit√© disponible. Entra√Ænez d'abord un mod√®le.")
                    
            except Exception as e:
                st.error(f"‚ùå Erreur lors du calcul des probabilit√©s: {e}")
    
    st.markdown("---")
    
    # Section 3.5: Backtesting - Optimisation des param√®tres
    st.header("üî¨ Backtesting - Optimisation des param√®tres")
    
    with st.expander("‚ÑπÔ∏è Qu'est-ce que le backtesting?", expanded=False):
        st.markdown("""
        **Le backtesting permet de tester diff√©rentes configurations** (graines + m√©thodes) 
        sur les tirages pass√©s pour identifier lesquelles auraient donn√© les meilleurs r√©sultats.
        
        **Pourquoi c'est utile:**
        - üéØ Trouve la **meilleure graine** automatiquement
        - üìä Compare objectivement les **diff√©rentes m√©thodes**
        - üîç Analyse les performances sur les **tirages r√©els**
        - üí° Vous dit **exactement quels param√®tres** utiliser
        
        **Note:** Les performances pass√©es ne garantissent pas les r√©sultats futurs, 
        mais permettent d'optimiser vos choix de mani√®re scientifique.
        """)
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üé≤ Graines √† tester")
        seed_option = st.radio(
            "Plage de graines",
            options=["Rapide (10 graines)", "Standard (25 graines)", "Complet (50 graines)", "Personnalis√©"],
            index=1
        )
        
        if seed_option == "Rapide (10 graines)":
            seeds_to_test = [1, 10, 20, 30, 40, 42, 50, 75, 100, 150]
        elif seed_option == "Standard (25 graines)":
            seeds_to_test = list(range(1, 26))
        elif seed_option == "Complet (50 graines)":
            seeds_to_test = list(range(1, 51))
        else:  # Personnalis√©
            seed_start = st.number_input("Graine de d√©but", min_value=1, max_value=9999, value=1)
            seed_end = st.number_input("Graine de fin", min_value=1, max_value=9999, value=50)
            seeds_to_test = list(range(seed_start, seed_end + 1))
        
        st.caption(f"üìä {len(seeds_to_test)} graines √† tester")
    
    with col2:
        st.subheader("üéØ M√©thodes √† tester")
        methods_to_test = st.multiselect(
            "S√©lectionnez les m√©thodes",
            options=["topk", "random", "hybrid", "ensemble", "advanced_hybrid"],
            default=["topk", "random", "hybrid"]
        )
        
        if not methods_to_test:
            st.warning("‚ö†Ô∏è S√©lectionnez au moins une m√©thode")
    
    col3, col4 = st.columns(2)
    
    with col3:
        n_draws_backtest = st.slider(
            "Nombre de tirages √† analyser",
            min_value=10,
            max_value=100,
            value=30,
            help="Plus = plus pr√©cis mais plus lent"
        )
    
    with col4:
        n_tickets_backtest = st.slider(
            "Tickets par tirage",
            min_value=5,
            max_value=20,
            value=10,
            help="Nombre de tickets g√©n√©r√©s pour chaque test"
        )
    
    # Estimation du temps
    total_tests = len(seeds_to_test) * len(methods_to_test)
    estimated_time = total_tests * 0.5  # ~0.5 sec par test
    
    st.info(f"‚è±Ô∏è Tests √† effectuer: **{total_tests}** | Dur√©e estim√©e: **~{estimated_time/60:.1f} minutes**")
    
    if st.button("üöÄ Lancer le backtesting", use_container_width=True, type="primary"):
        if not methods_to_test:
            st.error("‚ùå Veuillez s√©lectionner au moins une m√©thode")
        else:
            with st.spinner(f"Backtesting en cours... ({total_tests} tests)"):
                try:
                    df_results = run_backtesting(
                        seeds=seeds_to_test,
                        methods=methods_to_test,
                        n_draws=n_draws_backtest,
                        n_tickets=n_tickets_backtest
                    )
                    
                    if not df_results.empty:
                        st.success("‚úÖ Backtesting termin√©!")
                        
                        # Afficher le TOP 10
                        st.subheader("üèÜ TOP 10 Meilleures Configurations")
                        
                        top_10 = df_results.head(10).copy()
                        top_10['rank'] = range(1, len(top_10) + 1)
                        
                        # Formater pour l'affichage
                        display_df = top_10[[
                            'rank', 'seed', 'method', 'avg_score', 'avg_main', 
                            'avg_stars', 'best_main', 'best_stars', 'win_rate'
                        ]].copy()
                        
                        display_df.columns = [
                            'Rang', 'Graine', 'M√©thode', 'Score Moy', 'Nums Moy', 
                            '√âtoiles Moy', 'Meilleur Nums', 'Meilleur √âtoiles', 'Taux Gain %'
                        ]
                        
                        # Arrondir les valeurs
                        display_df['Score Moy'] = display_df['Score Moy'].round(2)
                        display_df['Nums Moy'] = display_df['Nums Moy'].round(2)
                        display_df['√âtoiles Moy'] = display_df['√âtoiles Moy'].round(2)
                        display_df['Taux Gain %'] = display_df['Taux Gain %'].round(1)
                        
                        st.dataframe(
                            display_df,
                            use_container_width=True,
                            hide_index=True
                        )
                        
                        # Recommandation
                        best_config = df_results.iloc[0]
                        st.success(f"""
                        üí° **RECOMMANDATION:**
                        
                        Utilisez **seed={int(best_config['seed'])}** avec la m√©thode **{best_config['method']}**
                        
                        Cette configuration a obtenu:
                        - Score moyen: **{best_config['avg_score']:.2f}**
                        - Num√©ros corrects (moy): **{best_config['avg_main']:.2f}/5**
                        - √âtoiles correctes (moy): **{best_config['avg_stars']:.2f}/2**
                        - Meilleur r√©sultat: **{int(best_config['best_main'])} num√©ros + {int(best_config['best_stars'])} √©toiles**
                        - Taux de gain: **{best_config['win_rate']:.1f}%**
                        """)
                        
                        # Graphique de comparaison des m√©thodes
                        st.subheader("üìä Comparaison des m√©thodes")
                        
                        method_comparison = df_results.groupby('method').agg({
                            'avg_score': 'mean',
                            'avg_main': 'mean',
                            'avg_stars': 'mean',
                            'win_rate': 'mean'
                        }).round(2)
                        
                        st.bar_chart(method_comparison['avg_score'])
                        
                        # Export des r√©sultats
                        st.subheader("üíæ Export des r√©sultats")
                        
                        csv_data = df_results.to_csv(index=False)
                        st.download_button(
                            label="üì• T√©l√©charger les r√©sultats (CSV)",
                            data=csv_data,
                            file_name=f"backtest_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                            mime="text/csv",
                            use_container_width=True
                        )
                        
                        # D√©tails par graine pour la meilleure m√©thode
                        if len(methods_to_test) > 1:
                            st.subheader("üîç D√©tails par graine (meilleure m√©thode)")
                            best_method = best_config['method']
                            method_details = df_results[df_results['method'] == best_method].head(10)
                            
                            st.line_chart(
                                method_details.set_index('seed')['avg_score'],
                                use_container_width=True
                            )
                    else:
                        st.warning("‚ö†Ô∏è Aucun r√©sultat obtenu")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors du backtesting: {e}")
                    import traceback
                    st.code(traceback.format_exc())
    
    st.markdown("---")
    
    # Section 4: Generate Tickets
    st.header("üé´ G√©n√©rer des tickets 5+2")
    
    if st.button("üé≤ G√©n√©rer les tickets", use_container_width=True):
        with st.spinner(f"G√©n√©ration de {n_tickets} tickets avec la m√©thode {method}..."):
            try:
                tickets = suggest_tickets_ui(n_tickets, method, seed, use_ensemble, hybrid_weights)
                
                if tickets:
                    st.success(f"‚úÖ {len(tickets)} tickets g√©n√©r√©s avec succ√®s!")
                    
                    # Display tickets
                    st.subheader("üé´ Vos tickets EuroMillions")
                    
                    tickets_text = format_tickets_display(tickets)
                    st.markdown(tickets_text)
                    
                    # Prepare download data
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    
                    # CSV format
                    csv_data = []
                    csv_data.append("Ticket,Boule1,Boule2,Boule3,Boule4,Boule5,Etoile1,Etoile2")
                    for ticket in tickets:
                        balls = ticket['balls']
                        stars = ticket['stars']
                        csv_data.append(f"{ticket['ticket_id']},{balls[0]},{balls[1]},{balls[2]},{balls[3]},{balls[4]},{stars[0]},{stars[1]}")
                    csv_content = '\n'.join(csv_data)
                    
                    # JSON format
                    json_content = json.dumps({
                        "generated_at": datetime.now().isoformat(),
                        "method": method,
                        "seed": seed,
                        "tickets": tickets
                    }, indent=2, ensure_ascii=False)
                    
                    # Download buttons
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.download_button(
                            label="‚¨áÔ∏è T√©l√©charger CSV",
                            data=csv_content,
                            file_name=f"euromillions_tickets_{timestamp}.csv",
                            mime="text/csv",
                            use_container_width=True
                        )
                    
                    with col2:
                        st.download_button(
                            label="‚¨áÔ∏è T√©l√©charger JSON",
                            data=json_content,
                            file_name=f"euromillions_tickets_{timestamp}.json",
                            mime="application/json",
                            use_container_width=True
                        )
                    
                    # Method explanation
                    st.info(f"**M√©thode utilis√©e:** {method} | **Graine:** {seed}")
                    
                    method_explanations = {
                        "topk": "S√©lectionne les boules/√©toiles avec les plus hautes probabilit√©s",
                        "random": "√âchantillonnage al√©atoire pond√©r√© par les probabilit√©s",
                        "hybrid": "M√©lange de pr√©dictions top et d'√©chantillonnage al√©atoire",
                        "ensemble": "Combine plusieurs algorithmes ML (LightGBM, XGBoost, CatBoost, RandomForest)",
                        "advanced_hybrid": "Strat√©gie hybride avanc√©e (ML + fr√©quences + motifs + √©carts)",
                        "enhanced_hybrid": "Version am√©lior√©e de la m√©thode hybride avec ensemble",
                        "enhanced_topk": "Version am√©lior√©e du top-k avec ensemble",
                        "enhanced_random": "Version am√©lior√©e de l'al√©atoire avec ensemble"
                    }
                    
                    st.caption(method_explanations.get(method, "M√©thode personnalis√©e"))
                
                else:
                    st.warning("‚ö†Ô∏è Aucun ticket g√©n√©r√©. V√©rifiez que les mod√®les sont entra√Æn√©s.")
                    
            except Exception as e:
                st.error(f"‚ùå Erreur lors de la g√©n√©ration: {e}")
    
    st.markdown("---")
    
    # Section 5: Manual Draw Entry
    st.header("‚ûï Ajouter un tirage manuellement")
    
    with st.expander("üìù Saisir un nouveau tirage", expanded=False):
        st.subheader("Informations du tirage")
        
        # Date input
        draw_date = st.date_input(
            "Date du tirage",
            value=datetime.now().date(),
            help="Date du tirage officiel"
        )
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("üé± Num√©ros principaux (1-50)")
            main_numbers = []
            
            # 5 number inputs for main numbers
            for i in range(5):
                num = st.number_input(
                    f"Num√©ro {i+1}",
                    min_value=1,
                    max_value=50,
                    value=1,
                    key=f"main_{i}",
                    help=f"Num√©ro principal {i+1} (entre 1 et 50)"
                )
                main_numbers.append(num)
        
        with col2:
            st.subheader("‚≠ê √âtoiles (1-12)")
            stars = []
            
            # 2 star inputs
            for i in range(2):
                star = st.number_input(
                    f"√âtoile {i+1}",
                    min_value=1,
                    max_value=12,
                    value=1,
                    key=f"star_{i}",
                    help=f"√âtoile {i+1} (entre 1 et 12)"
                )
                stars.append(star)
        
        # Validation and preview
        col1, col2 = st.columns(2)
        
        with col1:
            # Validate inputs
            main_numbers_sorted = sorted(main_numbers)
            stars_sorted = sorted(stars)
            
            # Check for duplicates in main numbers
            main_duplicates = len(main_numbers) != len(set(main_numbers))
            # Check for duplicates in stars
            star_duplicates = len(stars) != len(set(stars))
            
            if main_duplicates:
                st.error("‚ùå Les num√©ros principaux doivent √™tre diff√©rents")
            elif star_duplicates:
                st.error("‚ùå Les √©toiles doivent √™tre diff√©rentes")
            else:
                st.success("‚úÖ Tirage valide")
                
                # Preview
                st.info(f"**Aper√ßu:** {' - '.join(map(str, main_numbers_sorted))} | ‚≠ê {' - '.join(map(str, stars_sorted))}")
        
        with col2:
            # Add button
            if st.button("üíæ Ajouter le tirage", disabled=main_duplicates or star_duplicates):
                with st.spinner("Ajout du tirage en cours..."):
                    try:
                        # Import here to avoid circular imports
                        from repository import EuromillionsRepository
                        
                        # Create draw ID
                        draw_id = f"EM-{draw_date.strftime('%Y-%m-%d')}"
                        
                        # Prepare draw data
                        draw_data = {
                            'draw_id': draw_id,
                            'draw_date': draw_date.strftime('%Y-%m-%d'),
                            'n1': main_numbers_sorted[0],
                            'n2': main_numbers_sorted[1],
                            'n3': main_numbers_sorted[2],
                            'n4': main_numbers_sorted[3],
                            'n5': main_numbers_sorted[4],
                            's1': stars_sorted[0],
                            's2': stars_sorted[1],
                            'jackpot': None,
                            'prize_table': None,
                            'raw_html': None
                        }
                        
                        # Save to database
                        repo = EuromillionsRepository()
                        result = repo.upsert_draws([draw_data])
                        
                        if result['inserted'] > 0:
                            st.success(f"‚úÖ Tirage ajout√© avec succ√®s ! (ID: {draw_id})")
                            st.info("üí° Pensez √† re-entra√Æner les mod√®les pour inclure ce nouveau tirage")
                        elif result['updated'] > 0:
                            st.warning(f"‚ö†Ô∏è Tirage existant mis √† jour (ID: {draw_id})")
                        else:
                            st.error("‚ùå √âchec de l'ajout du tirage")
                            
                    except Exception as e:
                        st.error(f"‚ùå Erreur lors de l'ajout: {e}")
    
    st.markdown("---")
    
    # Section 6: CSV Import
    st.header("üìÑ Import CSV")
    
    with st.expander("üìÇ Importer des tirages depuis un fichier CSV", expanded=False):
        st.subheader("T√©l√©chargement de fichier CSV")
        
        uploaded_file = st.file_uploader(
            "Choisissez un fichier CSV FDJ",
            type=['csv'],
            help="Fichier CSV au format FDJ avec les tirages EuroMillions"
        )
        
        if uploaded_file is not None:
            # Preview file content
            try:
                # Read a few lines for preview
                import io
                
                # Reset file pointer
                uploaded_file.seek(0)
                content = uploaded_file.read()
                
                # Try different encodings
                encodings = ['utf-8', 'latin1', 'cp1252']
                df_preview = None
                used_encoding = None
                
                for encoding in encodings:
                    try:
                        uploaded_file.seek(0)
                        df_preview = pd.read_csv(io.StringIO(content.decode(encoding)), nrows=5)
                        used_encoding = encoding
                        break
                    except:
                        continue
                
                if df_preview is not None:
                    st.subheader("Aper√ßu du fichier")
                    st.dataframe(df_preview, use_container_width=True)
                    
                    # Calculer le nombre de lignes sans backslash dans f-string
                    line_count = len(content.decode(used_encoding).split('\n'))
                    st.caption(f"Encodage d√©tect√©: {used_encoding} | Lignes totales: {line_count}")
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        if st.button("üîç Analyser le fichier complet"):
                            with st.spinner("Analyse du fichier..."):
                                try:
                                    uploaded_file.seek(0)
                                    df_full = pd.read_csv(io.StringIO(content.decode(used_encoding)))
                                    
                                    st.subheader("Statistiques du fichier")
                                    st.metric("Nombre de lignes", len(df_full))
                                    st.metric("Nombre de colonnes", len(df_full.columns))
                                    
                                    # Show column names
                                    st.subheader("Colonnes d√©tect√©es")
                                    st.write(list(df_full.columns))
                                    
                                except Exception as e:
                                    st.error(f"Erreur lors de l'analyse: {e}")
                    
                    with col2:
                        if st.button("üì• Importer les donn√©es"):
                            with st.spinner("Import des donn√©es en cours..."):
                                try:
                                    # Save temporarily and import
                                    import tempfile
                                    import os
                                    
                                    # Create temporary file
                                    with tempfile.NamedTemporaryFile(mode='wb', suffix='.csv', delete=False) as tmp_file:
                                        uploaded_file.seek(0)
                                        tmp_file.write(uploaded_file.read())
                                        temp_path = tmp_file.name
                                    
                                    # Import using existing function
                                    import subprocess
                                    import sys
                                    
                                    # Run import script
                                    result = subprocess.run([
                                        sys.executable, 'import_fdj_special.py', temp_path
                                    ], capture_output=True, text=True, cwd=os.getcwd())
                                    
                                    # Clean up
                                    os.unlink(temp_path)
                                    
                                    if result.returncode == 0:
                                        st.success("‚úÖ Import r√©ussi !")
                                        st.text("Sortie:")
                                        st.code(result.stdout)
                                        st.info("üí° Pensez √† re-entra√Æner les mod√®les avec les nouvelles donn√©es")
                                    else:
                                        st.error("‚ùå √âchec de l'import")
                                        st.text("Erreur:")
                                        st.code(result.stderr)
                                        
                                except Exception as e:
                                    st.error(f"‚ùå Erreur lors de l'import: {e}")
                else:
                    st.error("‚ùå Impossible de lire le fichier. V√©rifiez le format CSV.")
                    
            except Exception as e:
                st.error(f"‚ùå Erreur lors de la lecture du fichier: {e}")
    
    st.markdown("---")
    
    # Section 7: History
    st.header("üóÇÔ∏è Historique")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üìú Voir les 20 derniers tirages", use_container_width=True):
            with st.spinner("Chargement de l'historique..."):
                try:
                    recent_draws = fetch_last_draws(20)
                    
                    if not recent_draws.empty:
                        st.subheader("üìã Derniers tirages")
                        
                        # Format for display
                        display_df = recent_draws[['draw_date', 'balls', 'stars']].rename(columns={
                            'draw_date': 'Date',
                            'balls': 'Boules principales',
                            'stars': '√âtoiles'
                        })
                        
                        st.dataframe(
                            display_df,
                            use_container_width=True,
                            hide_index=True
                        )
                    else:
                        st.warning("‚ö†Ô∏è Aucun tirage trouv√© dans l'historique.")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors du chargement: {e}")
    
    with col2:
        if st.button("‚¨áÔ∏è Exporter l'historique (CSV)", use_container_width=True):
            with st.spinner("Pr√©paration de l'export..."):
                try:
                    filename, csv_bytes = export_all_draws_csv()
                    
                    if csv_bytes:
                        st.download_button(
                            label="üìÅ T√©l√©charger l'historique complet",
                            data=csv_bytes,
                            file_name=filename,
                            mime="text/csv",
                            use_container_width=True
                        )
                        
                        file_size = len(csv_bytes)
                        st.success(f"‚úÖ Export pr√™t: {filename} ({file_size:,} octets)")
                    else:
                        st.warning("‚ö†Ô∏è Aucune donn√©e √† exporter.")
                        
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de l'export: {e}")
    
    # Footer with system status
    st.markdown("---")
    
    with st.expander("‚ÑπÔ∏è √âtat du syst√®me"):
        try:
            status = get_system_status()
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("üìä Donn√©es")
                if status.get("data", {}).get("available", False):
                    data_info = status["data"]
                    st.success(f"‚úÖ {data_info['count']} tirages disponibles")
                    if data_info.get("first_date") and data_info.get("last_date"):
                        st.caption(f"Du {data_info['first_date']} au {data_info['last_date']}")
                else:
                    st.error("‚ùå Aucune donn√©e disponible")
            
            with col2:
                st.subheader("ü§ñ Mod√®les")
                if status.get("models", {}).get("available", False):
                    model_info = status["models"]
                    st.success("‚úÖ Mod√®les disponibles")
                    if model_info.get("trained_at"):
                        st.caption(f"Entra√Æn√©s le: {model_info['trained_at']}")
                else:
                    st.error("‚ùå Aucun mod√®le entra√Æn√©")
            
            # Recommendations
            recommendations = status.get("recommendations", [])
            if recommendations:
                st.subheader("üí° Recommandations")
                for rec in recommendations:
                    st.info(f"‚Ä¢ {rec}")
                    
        except Exception as e:
            st.error(f"‚ùå Erreur lors de la r√©cup√©ration du statut: {e}")


if __name__ == "__main__":
    main()
